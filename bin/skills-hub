#!/usr/bin/env node
'use strict';

const fsPromises = require('fs/promises');
const fse = require('fs-extra');
const path = require('path');
const os = require('os');
const simpleGit = require('simple-git');
const matter = require('gray-matter');

const args = process.argv.slice(2);
const commands = new Set(['import', 'list', 'diagnose', 'scan-projects', 'sync', 'snapshot', 'provider', 'kit', 'profile', 'conflicts']);
const flagsWithValues = new Set([
    '-b',
    '--branch',
    '--target',
    '-t',
    '--app',
    '--id',
    '--name',
    '--note',
    '--website',
    '--account-name',
    '--vendor-key',
    '--provider-id',
    '--claude-provider-id',
    '--codex-provider-id',
    '--gemini-provider-id',
    '--base-url',
    '--api-key',
    '--apps',
    '--claude-model',
    '--codex-model',
    '--gemini-model',
    '--config-json',
    '--config-file',
    '--kit-id',
    '--policy-id',
    '--loadout-id',
    '--description',
    '--skills',
    '--project',
    '--agent',
    '--mode',
    '--content',
    '--content-file',
]);
let providerCorePromise = null;
let kitServicePromise = null;
let syncServicePromise = null;
let snapshotServicePromise = null;
let profileServicePromise = null;
let diagnoseServicePromise = null;
let conflictServicePromise = null;
let scannerPromise = null;

let command = null;
let commandIndex = -1;

for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.startsWith('-')) {
        // Check if it's a flag=value style
        if (arg.includes('=')) continue;

        // Check if it's a flag that takes a value next
        if (flagsWithValues.has(arg)) {
            i++; // Skip the next argument (the value)
        }
    } else {
        // Found the first non-flag argument, closest thing to a command
        command = arg;
        commandIndex = i;
        break;
    }
}

if (args.includes('--help') || args.includes('-h')) {
    printHelp();
    process.exit(0);
}

if (args.includes('--version') || args.includes('-v') || args.includes('-V')) {
    const pkg = require(path.join(__dirname, '..', 'package.json'));
    console.log(pkg.version);
    process.exit(0);
}

if (command && !commands.has(command)) {
    console.error(`Unknown command: ${command}`);
    printHelp();
    process.exit(1);
}

if (command) {
    const commandArgs = args.slice(commandIndex + 1);
    runCommand(command, commandArgs).catch((error) => {
        console.error(`Command failed: ${error.message || error}`);
        process.exit(1);
    });
} else {
    printHelp();
    process.exit(1);
}

function printHelp() {
    console.log(`Usage:
  skills-hub <command> [options]

Commands:
  import <url> [--branch <branch>]   Import a skill from a git repository
  list                               List skills in the hub directory
  diagnose [--json] [--project <path>] [--agent <path>]
                                     Diagnose skill readiness and missing requirements
  scan-projects [--force]            Scan configured roots for git projects with incremental cache
  conflicts [--json]                 Detect duplicate plugin ids / cross-source skill name conflicts
  sync --all | --target <name> [--dry-run]       Sync hub skills to agent targets
  snapshot <subcommand>              Manage sync/apply snapshots and rollback
  provider <subcommand>              Manage provider profiles and switching
  kit <subcommand>                   Manage AGENTS templates, loadouts, and kits
  profile <subcommand>               Manage project profile bindings

Snapshot subcommands:
  snapshot list
  snapshot rollback --id <snapshotId>
  snapshot rollback --last

Provider subcommands:
  provider list [--app <app>]                                List providers
  provider add --app <app> --name <name> --config-json <json>
  provider add --app <app> --name <name> --config-file <path>
  provider update --id <id> [--name <name>] [--config-json <json>|--config-file <path>]
  provider switch --app <app> --id <providerId>              Switch current provider
  provider delete --id <providerId>                          Delete a provider
  provider restore --app <app>                               Restore latest live backup
  provider capture --app <app> --name <name>                 Capture current live config as provider
  provider universal-list                                     List universal providers
  provider universal-add --name <name> --base-url <url> --api-key <key> [--apps claude,codex,gemini]
  provider universal-apply --id <universalProviderId>        Apply universal provider to enabled apps
  provider universal-delete --id <universalProviderId>       Delete universal provider

Kit subcommands:
  kit policy-list
  kit policy-add --name <name> [--description <text>] (--content <text> | --content-file <path>)
  kit policy-update --id <id> [--name <name>] [--description <text>] [--content <text>|--content-file <path>]
  kit policy-delete --id <id>
  kit loadout-list
  kit loadout-add --name <name> --skills <path1,path2,...> [--description <text>] [--mode copy|link]
  kit loadout-update --id <id> [--name <name>] [--description <text>] [--skills <path1,path2,...>] [--mode copy|link]
  kit loadout-delete --id <id>
  kit list
  kit add --name <name> --policy-id <id> --loadout-id <id> [--description <text>]
  kit update --id <id> [--name <name>] [--policy-id <id>] [--loadout-id <id>] [--description <text>]
  kit delete --id <id>
  kit apply --id <id> --project <path> --agent <name> [--mode copy|link] [--overwrite-agents-md] [--dry-run]

Profile subcommands:
  profile list
  profile add --name <name> --project <path> [--kit-id <id>] [--provider-id <universalId>] [--claude-provider-id <id>] [--codex-provider-id <id>] [--gemini-provider-id <id>] [--default]
  profile update --id <id> [--name <name>] [--project <path>] [--kit-id <id>] [--provider-id <universalId>] [--claude-provider-id <id>] [--codex-provider-id <id>] [--gemini-provider-id <id>] [--default] [--unset-default]
  profile delete --id <id>
  profile apply (--project <path> | --id <id>) [--agent <name>] [--mode copy|link] [--overwrite-agents-md]

  -v, --version       Show version number
  -h, --help          Show this help message
`);
}

function readArgValue(argv, flag, shortFlag) {
    const index = argv.indexOf(flag);
    if (index !== -1 && index + 1 < argv.length) {
        return argv[index + 1];
    }

    if (shortFlag) {
        const shortIndex = argv.indexOf(shortFlag);
        if (shortIndex !== -1 && shortIndex + 1 < argv.length) {
            return argv[shortIndex + 1];
        }
    }

    const withEq = argv.find((arg) => arg.startsWith(`${flag}=`));
    if (withEq) {
        return withEq.split('=').slice(1).join('=');
    }

    return null;
}

function readArgValues(argv, flag, shortFlag) {
    const values = [];

    for (let index = 0; index < argv.length; index += 1) {
        const arg = argv[index];
        if (arg === flag || (shortFlag && arg === shortFlag)) {
            if (index + 1 < argv.length) {
                values.push(argv[index + 1]);
                index += 1;
            }
            continue;
        }

        if (arg.startsWith(`${flag}=`)) {
            values.push(arg.split('=').slice(1).join('='));
            continue;
        }

        if (shortFlag && arg.startsWith(`${shortFlag}=`)) {
            values.push(arg.split('=').slice(1).join('='));
        }
    }

    return values;
}

function expandHome(inputPath) {
    if (!inputPath) return inputPath;
    if (inputPath.startsWith('~')) {
        return path.join(os.homedir(), inputPath.slice(1));
    }
    return inputPath;
}

function normalizeRepoWebUrl(url) {
    return url.trim().replace(/\/$/, '').replace(/\.git$/, '');
}

function parseSkillImportUrl(url, preferredBranch) {
    const input = url.trim();
    if (!input) {
        throw new Error('Missing URL for import.');
    }

    let repoWebUrl = '';
    let branch = preferredBranch ? preferredBranch.trim() : '';
    let subdir = '';

    if (input.includes('/tree/')) {
        const [base, restRaw = ''] = input.split('/tree/', 2);
        repoWebUrl = normalizeRepoWebUrl(base);

        const rest = restRaw.replace(/^\/+/, '');
        if (rest) {
            const parts = rest.split('/').filter(Boolean);
            if (!branch && parts.length > 0) {
                branch = parts[0];
            }
            if (parts.length > 1) {
                subdir = parts.slice(1).join('/');
            }
        }
    } else {
        repoWebUrl = normalizeRepoWebUrl(input);
    }

    const skillName = subdir ? path.basename(subdir) : path.basename(repoWebUrl);
    if (!repoWebUrl || !skillName) {
        throw new Error('Invalid skill import URL.');
    }

    return {
        repoUrl: `${repoWebUrl}.git`,
        repoWebUrl,
        branch: branch || undefined,
        subdir,
        skillName,
    };
}

function buildGitSourceUrl(repoWebUrl, branch, subdir) {
    const normalized = normalizeRepoWebUrl(repoWebUrl);
    if (!branch) {
        return normalized;
    }
    if (subdir) {
        return `${normalized}/tree/${branch}/${subdir}`;
    }
    return `${normalized}/tree/${branch}`;
}

async function attachSkillImportMetadata(skillDirPath, metadata) {
    const skillMdPath = path.join(skillDirPath, 'SKILL.md');
    if (!await fse.pathExists(skillMdPath)) {
        return;
    }

    const rawContent = await fsPromises.readFile(skillMdPath, 'utf-8');
    const parsed = matter(rawContent);
    const { source_branch: _ignoredSourceBranch, ...restFrontmatter } = parsed.data || {};
    const nextFrontmatter = {
        ...restFrontmatter,
        source_repo: metadata.sourceRepo,
        source_url: metadata.sourceUrl,
        source_subdir: metadata.sourceSubdir || '/',
        source_last_updated: metadata.sourceLastUpdated,
        imported_at: metadata.importedAt,
    };

    const nextRawContent = matter.stringify(parsed.content, nextFrontmatter);
    await fsPromises.writeFile(skillMdPath, nextRawContent, 'utf-8');
}

async function runCommand(commandName, commandArgs) {
    switch (commandName) {
        case 'import':
            await handleImport(commandArgs);
            return;
        case 'list':
            await handleList();
            return;
        case 'diagnose':
            await handleDiagnose(commandArgs);
            return;
        case 'scan-projects':
            await handleScanProjects(commandArgs);
            return;
        case 'sync':
            await handleSync(commandArgs);
            return;
        case 'conflicts':
            await handleConflicts(commandArgs);
            return;
        case 'snapshot':
            await handleSnapshot(commandArgs);
            return;
        case 'provider':
            await handleProvider(commandArgs);
            return;
        case 'kit':
            await handleKit(commandArgs);
            return;
        case 'profile':
            await handleProfile(commandArgs);
            return;
        default:
            console.error(`Unknown command: ${commandName}`);
            process.exit(1);
    }
}

function loadProviderCore() {
    if (!providerCorePromise) {
        providerCorePromise = import('../lib/core/provider-core.mjs');
    }
    return providerCorePromise;
}

function loadKitService() {
    if (!kitServicePromise) {
        kitServicePromise = import('../lib/services/kit-service.mjs');
    }
    return kitServicePromise;
}

function loadSyncService() {
    if (!syncServicePromise) {
        syncServicePromise = import('../lib/services/sync-service.mjs');
    }
    return syncServicePromise;
}

function loadSnapshotService() {
    if (!snapshotServicePromise) {
        snapshotServicePromise = import('../lib/services/snapshot-service.mjs');
    }
    return snapshotServicePromise;
}

function loadProfileService() {
    if (!profileServicePromise) {
        profileServicePromise = import('../lib/services/profile-service.mjs');
    }
    return profileServicePromise;
}

function loadDiagnoseService() {
    if (!diagnoseServicePromise) {
        diagnoseServicePromise = import('../lib/services/diagnose-service.mjs');
    }
    return diagnoseServicePromise;
}

function loadConflictService() {
    if (!conflictServicePromise) {
        conflictServicePromise = import('../lib/services/conflict-service.mjs');
    }
    return conflictServicePromise;
}

function loadScanner() {
    if (!scannerPromise) {
        scannerPromise = import('../lib/scanner-core.mjs');
    }
    return scannerPromise;
}

function parseJsonArg(jsonText) {
    try {
        const parsed = JSON.parse(jsonText);
        if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {
            throw new Error('must be a JSON object');
        }
        return parsed;
    } catch (error) {
        throw new Error(`Invalid JSON config: ${error.message || error}`);
    }
}

async function readProviderConfigFromArgs(commandArgs) {
    const configJson = readArgValue(commandArgs, '--config-json');
    const configFile = readArgValue(commandArgs, '--config-file');

    if (configJson && configFile) {
        throw new Error('Use either --config-json or --config-file, not both.');
    }

    if (configJson) {
        return parseJsonArg(configJson);
    }

    if (configFile) {
        const resolved = path.resolve(configFile);
        const raw = await fsPromises.readFile(resolved, 'utf-8');
        return parseJsonArg(raw);
    }

    return undefined;
}

function readProviderProfileArgs(commandArgs, defaultKind = 'api') {
    const note = readArgValue(commandArgs, '--note');
    const website = readArgValue(commandArgs, '--website');
    const accountName = readArgValue(commandArgs, '--account-name');
    const vendorKey = readArgValue(commandArgs, '--vendor-key');

    return {
        kind: defaultKind,
        note: note || undefined,
        website: website || undefined,
        accountName: accountName || undefined,
        vendorKey: vendorKey || undefined,
    };
}

function hasFlag(argv, flag) {
    return argv.includes(flag);
}

function hasValueFlag(argv, flag) {
    return argv.includes(flag) || argv.some((arg) => arg.startsWith(`${flag}=`));
}

function printDryRunPreview(preview) {
    console.log(JSON.stringify(preview));
    const summary = preview && preview.summary && typeof preview.summary === 'object'
        ? preview.summary
        : { total: 0, add: 0, update: 0, delete: 0, link: 0 };
    console.log(
        `Dry run summary: total=${summary.total}, add=${summary.add}, ` +
        `update=${summary.update}, delete=${summary.delete}, link=${summary.link}`
    );

    if (Array.isArray(preview?.warnings) && preview.warnings.length > 0) {
        for (const warning of preview.warnings) {
            console.log(`Warning: ${warning}`);
        }
    }
}

function normalizeKitMode(modeRaw) {
    if (!modeRaw) return 'copy';
    const normalized = String(modeRaw).trim().toLowerCase();
    if (normalized === 'copy' || normalized === 'link') {
        return normalized;
    }
    throw new Error(`Invalid --mode value: ${modeRaw}. Use copy or link.`);
}

function parseSkillsArg(skillsRaw) {
    if (!skillsRaw || !skillsRaw.trim()) {
        throw new Error('Missing --skills value.');
    }

    const skillPaths = skillsRaw
        .split(',')
        .map((entry) => entry.trim())
        .filter(Boolean);

    if (skillPaths.length === 0) {
        throw new Error('At least one skill path is required in --skills.');
    }

    return Array.from(new Set(skillPaths));
}

async function readContentFromArgs(commandArgs) {
    const content = readArgValue(commandArgs, '--content');
    const contentFile = readArgValue(commandArgs, '--content-file');

    if (content && contentFile) {
        throw new Error('Use either --content or --content-file, not both.');
    }

    if (contentFile) {
        const resolved = path.resolve(contentFile);
        return fsPromises.readFile(resolved, 'utf-8');
    }

    if (content) {
        return content;
    }

    return undefined;
}

function readUniversalApps(commandArgs) {
    const raw = readArgValue(commandArgs, '--apps');
    if (!raw) {
        return {
            claude: true,
            codex: true,
            gemini: true,
        };
    }

    const set = new Set(
        raw
            .split(',')
            .map((item) => item.trim().toLowerCase())
            .filter(Boolean)
    );

    return {
        claude: set.has('claude'),
        codex: set.has('codex'),
        gemini: set.has('gemini'),
    };
}

function readUniversalModels(commandArgs) {
    const claudeModel = readArgValue(commandArgs, '--claude-model');
    const codexModel = readArgValue(commandArgs, '--codex-model');
    const geminiModel = readArgValue(commandArgs, '--gemini-model');

    return {
        claude: { model: claudeModel || undefined },
        codex: { model: codexModel || undefined },
        gemini: { model: geminiModel || undefined },
    };
}

function readProfileProviderByApp(commandArgs) {
    const claudeFlag = hasValueFlag(commandArgs, '--claude-provider-id');
    const codexFlag = hasValueFlag(commandArgs, '--codex-provider-id');
    const geminiFlag = hasValueFlag(commandArgs, '--gemini-provider-id');
    const claudeProviderId = readArgValue(commandArgs, '--claude-provider-id');
    const codexProviderId = readArgValue(commandArgs, '--codex-provider-id');
    const geminiProviderId = readArgValue(commandArgs, '--gemini-provider-id');

    if (claudeFlag && !claudeProviderId) {
        throw new Error('Missing value for --claude-provider-id');
    }
    if (codexFlag && !codexProviderId) {
        throw new Error('Missing value for --codex-provider-id');
    }
    if (geminiFlag && !geminiProviderId) {
        throw new Error('Missing value for --gemini-provider-id');
    }

    const providerByApp = {};
    if (claudeProviderId) {
        providerByApp.claude = claudeProviderId;
    }
    if (codexProviderId) {
        providerByApp.codex = codexProviderId;
    }
    if (geminiProviderId) {
        providerByApp.gemini = geminiProviderId;
    }

    return providerByApp;
}

function formatProfileProviderBinding(profile) {
    if (profile.providerId) {
        return `universal:${profile.providerId}`;
    }

    const byApp = profile.providerByApp && typeof profile.providerByApp === 'object'
        ? profile.providerByApp
        : {};

    const labels = ['claude', 'codex', 'gemini']
        .filter((app) => byApp[app])
        .map((app) => `${app}:${byApp[app]}`);
    return labels.length > 0 ? labels.join(',') : 'none';
}

function printProviderRow(provider) {
    const currentLabel = provider.isCurrent ? ' (current)' : '';
    console.log(`- ${provider.id} | ${provider.appType} | ${provider.name}${currentLabel}`);
}

function printUniversalProviderRow(provider) {
    const enabledApps = ['claude', 'codex', 'gemini'].filter((app) => provider.apps?.[app]).join(',');
    console.log(`- ${provider.id} | ${provider.name} | ${provider.baseUrl} | apps=${enabledApps || 'none'}`);
}

function printKitPolicyRow(policy) {
    console.log(`- ${policy.id} | ${policy.name}${policy.description ? ` | ${policy.description}` : ''}`);
}

function printKitLoadoutRow(loadout) {
    console.log(`- ${loadout.id} | ${loadout.name} | skills=${loadout.items.length}`);
}

function printKitRow(kit) {
    console.log(`- ${kit.id} | ${kit.name} | policy=${kit.policyId} | loadout=${kit.loadoutId}`);
}

function printProfileRow(profile) {
    const defaultLabel = profile.isDefault ? ' | default' : '';
    const kitLabel = profile.kitId ? profile.kitId : 'none';
    const providerLabel = formatProfileProviderBinding(profile);
    console.log(
        `- ${profile.id} | ${profile.name} | project=${profile.projectPath} | ` +
        `kit=${kitLabel} | provider=${providerLabel}${defaultLabel}`
    );
}

function printSnapshotRow(snapshot) {
    const affectedCount = Array.isArray(snapshot?.affectedPaths) ? snapshot.affectedPaths.length : 0;
    console.log(
        `- ${snapshot.id} | ${snapshot.createdAt} | ${snapshot.operation} | ` +
        `target=${snapshot.target} | mode=${snapshot.mode} | paths=${affectedCount}`
    );
}

function normalizeConfigPath(inputPath) {
    const expanded = expandHome(String(inputPath || '').trim());
    if (!expanded) return '';
    return path.resolve(expanded);
}

function normalizeConfigForConflictScan(config) {
    const projects = Array.isArray(config?.projects) ? config.projects : [];
    const agents = Array.isArray(config?.agents) ? config.agents : [];

    return {
        ...config,
        hubPath: normalizeConfigPath(config?.hubPath),
        projects: projects.map((projectPath) => normalizeConfigPath(projectPath)).filter(Boolean),
        agents: agents.map((agent) => ({
            ...agent,
            globalPath: normalizeConfigPath(agent?.globalPath),
            projectPath: String(agent?.projectPath || '').trim(),
        })),
    };
}

function normalizePathArgList(values) {
    const normalized = [];
    const seen = new Set();

    for (const value of Array.isArray(values) ? values : []) {
        const normalizedPath = normalizeConfigPath(value);
        if (!normalizedPath || seen.has(normalizedPath)) continue;
        seen.add(normalizedPath);
        normalized.push(normalizedPath);
    }

    return normalized;
}

function buildDiagnoseTargets(config, commandArgs) {
    const projectRoots = normalizePathArgList(readArgValues(commandArgs, '--project'));
    const agentRoots = normalizePathArgList(readArgValues(commandArgs, '--agent'));
    const enabledAgents = (Array.isArray(config?.agents) ? config.agents : []).filter((agent) => agent?.enabled);
    const projectSkillRelPaths = Array.from(
        new Set(
            enabledAgents
                .map((agent) => String(agent?.projectPath || '').trim())
                .filter(Boolean)
        )
    );

    const targets = [];
    if (config?.hubPath) {
        targets.push({
            kind: 'hub',
            path: config.hubPath,
            label: 'hub',
        });
    }

    for (const projectRoot of projectRoots) {
        targets.push({
            kind: 'project',
            path: projectRoot,
            label: `project:${projectRoot}`,
        });

        for (const relativeSkillPath of projectSkillRelPaths) {
            targets.push({
                kind: 'project',
                path: path.resolve(projectRoot, relativeSkillPath),
                label: `project:${projectRoot}:${relativeSkillPath}`,
            });
        }
    }

    for (const agentRoot of agentRoots) {
        targets.push({
            kind: 'agent',
            path: agentRoot,
            label: `agent:${agentRoot}`,
        });
    }

    return targets;
}

function printDiagnoseReason(reason, index) {
    console.log(`   ${index + 1}. [${reason.code}] ${reason.message}`);
    if (reason?.suggestion) {
        console.log(`      Fix: ${reason.suggestion}`);
    }
}

function printDiagnoseReport(report) {
    const totalSkills = report?.summary?.totalSkills || 0;
    const readySkills = report?.summary?.readySkills || 0;
    const notReadySkills = report?.summary?.notReadySkills || 0;
    const totalReasons = report?.summary?.totalReasons || 0;

    console.log(
        `Diagnosed ${totalSkills} skill(s): ` +
        `ready=${readySkills}, not-ready=${notReadySkills}, reasons=${totalReasons}`
    );

    const missingTargets = (report?.targets || []).filter((target) => !target.exists);
    for (const target of missingTargets) {
        console.log(`- Skipped missing path [${target.kind}]: ${target.path}`);
    }

    if (totalSkills === 0) {
        console.log('No skills found in selected paths.');
        return;
    }

    if (notReadySkills === 0) {
        console.log('All diagnosed skills are ready.');
        return;
    }

    for (const skill of report.skills.filter((item) => !item.ready)) {
        console.log(`\n- ${skill.name} [${skill.source}] ${skill.path}`);
        for (const [index, reason] of skill.reasons.entries()) {
            printDiagnoseReason(reason, index);
        }
    }
}

async function handleDiagnose(commandArgs) {
    const outputJson = hasFlag(commandArgs, '--json');
    const config = normalizeConfigForConflictScan(await loadConfig());
    const diagnoseService = await loadDiagnoseService();
    const report = await diagnoseService.diagnoseSkills({
        targets: buildDiagnoseTargets(config, commandArgs),
        config,
        env: process.env,
    });

    if (outputJson) {
        console.log(JSON.stringify(report, null, 2));
        return;
    }

    printDiagnoseReport(report);
}

function printConflictItem(item) {
    const source = item?.sourceLabel || item?.sourceType || 'unknown';
    const pluginLabel = item?.pluginId ? ` | plugin_id=${item.pluginId}` : '';
    console.log(`   - ${source} | ${item.path}${pluginLabel}`);
}

function printConflict(conflict, index) {
    const key = conflict?.key || 'unknown';
    console.log(`${index + 1}. [${conflict.type}] ${key}`);
    for (const item of conflict.items || []) {
        printConflictItem(item);
    }
    console.log(`   Suggested resolution: ${conflict.resolution}`);
}

async function handleConflicts(commandArgs) {
    const outputJson = hasFlag(commandArgs, '--json');
    const conflictService = await loadConflictService();
    const config = await loadConfig();
    const report = await conflictService.collectSkillConflicts(normalizeConfigForConflictScan(config));

    if (outputJson) {
        console.log(JSON.stringify(report, null, 2));
        return;
    }

    if (report.conflictCount === 0) {
        console.log(`No conflicts found across ${report.itemCount} discovered skills.`);
        return;
    }

    console.log(`Found ${report.conflictCount} conflict(s) across ${report.itemCount} discovered skills:`);
    report.conflicts.forEach((conflict, index) => printConflict(conflict, index));
}

async function handleSnapshot(commandArgs) {
    const subcommand = commandArgs[0];
    if (!subcommand) {
        throw new Error('Missing snapshot subcommand. Try: snapshot list|rollback');
    }

    const snapshotService = await loadSnapshotService();

    switch (subcommand) {
        case 'list': {
            const snapshots = await snapshotService.listSnapshots();
            if (snapshots.length === 0) {
                console.log('No snapshots found.');
                return;
            }
            snapshots.forEach(printSnapshotRow);
            return;
        }
        case 'rollback': {
            const rest = commandArgs.slice(1);
            const snapshotId = readArgValue(rest, '--id');
            const useLast = hasFlag(rest, '--last');

            if ((snapshotId && useLast) || (!snapshotId && !useLast)) {
                throw new Error('snapshot rollback requires exactly one of --id <snapshotId> or --last');
            }

            let resolvedId = snapshotId;
            if (useLast) {
                const latest = await snapshotService.getLatestSnapshot();
                if (!latest) {
                    throw new Error('No snapshots available for rollback.');
                }
                resolvedId = latest.id;
            }

            const result = await snapshotService.rollbackSnapshot({ id: resolvedId });
            console.log(
                `Snapshot rolled back: ${result.id} | op=${result.operation} | ` +
                `restored=${result.restoredPaths} | removed=${result.removedPaths} | total=${result.totalPaths}`
            );
            return;
        }
        default:
            throw new Error(`Unknown snapshot subcommand: ${subcommand}`);
    }
}

async function handleProfile(commandArgs) {
    const subcommand = commandArgs[0];
    if (!subcommand) {
        throw new Error('Missing profile subcommand. Try: profile list|add|update|delete|apply');
    }

    const profileService = await loadProfileService();

    switch (subcommand) {
        case 'list': {
            const result = await profileService.listProfiles();
            if (result.profiles.length === 0) {
                console.log('No profiles found.');
                return;
            }
            result.profiles.forEach(printProfileRow);
            if (!result.defaultProfileId) {
                console.log('Global default profile: none');
            }
            return;
        }
        case 'add': {
            const rest = commandArgs.slice(1);
            const name = readArgValue(rest, '--name');
            const projectPath = readArgValue(rest, '--project');
            const kitIdFlag = hasValueFlag(rest, '--kit-id');
            const kitId = readArgValue(rest, '--kit-id');
            const providerIdFlag = hasValueFlag(rest, '--provider-id');
            const providerId = readArgValue(rest, '--provider-id');
            const providerByApp = readProfileProviderByApp(rest);
            const setDefault = hasFlag(rest, '--default');

            if (!name || !projectPath) {
                throw new Error('profile add requires --name and --project');
            }
            if (kitIdFlag && !kitId) {
                throw new Error('profile add requires a value for --kit-id');
            }
            if (providerIdFlag && !providerId) {
                throw new Error('profile add requires a value for --provider-id');
            }

            const profile = await profileService.addProfile({
                name,
                projectPath,
                kitId: kitId || undefined,
                providerId: providerId || undefined,
                providerByApp,
                setDefault,
            });
            console.log(
                `Profile created: ${profile.id} (${profile.name})` +
                `${profile.isDefault ? ' [default]' : ''}`
            );
            return;
        }
        case 'update': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('profile update requires --id');
            }

            const setDefault = hasFlag(rest, '--default');
            const unsetDefault = hasFlag(rest, '--unset-default');
            if (setDefault && unsetDefault) {
                throw new Error('profile update cannot use --default with --unset-default');
            }

            const hasName = hasValueFlag(rest, '--name');
            const hasProject = hasValueFlag(rest, '--project');
            const hasKitId = hasValueFlag(rest, '--kit-id');
            const hasProviderId = hasValueFlag(rest, '--provider-id');
            const hasClaudeProviderId = hasValueFlag(rest, '--claude-provider-id');
            const hasCodexProviderId = hasValueFlag(rest, '--codex-provider-id');
            const hasGeminiProviderId = hasValueFlag(rest, '--gemini-provider-id');
            const hasProviderByApp = hasClaudeProviderId || hasCodexProviderId || hasGeminiProviderId;

            if (!hasName && !hasProject && !hasKitId && !hasProviderId && !hasProviderByApp && !setDefault && !unsetDefault) {
                throw new Error('profile update requires at least one field to update');
            }

            const payload = { id };

            if (hasName) {
                const name = readArgValue(rest, '--name');
                if (!name) {
                    throw new Error('profile update requires a value for --name');
                }
                payload.name = name;
            }

            if (hasProject) {
                const projectPath = readArgValue(rest, '--project');
                if (!projectPath) {
                    throw new Error('profile update requires a value for --project');
                }
                payload.projectPath = projectPath;
            }

            if (hasKitId) {
                const kitId = readArgValue(rest, '--kit-id');
                if (!kitId) {
                    throw new Error('profile update requires a value for --kit-id');
                }
                payload.kitId = kitId;
            }

            if (hasProviderId) {
                const providerId = readArgValue(rest, '--provider-id');
                if (!providerId) {
                    throw new Error('profile update requires a value for --provider-id');
                }
                payload.providerId = providerId;
            }

            if (hasProviderByApp) {
                payload.providerByApp = readProfileProviderByApp(rest);
            }

            if (setDefault) {
                payload.setDefault = true;
            }

            if (unsetDefault) {
                payload.unsetDefault = true;
            }

            const profile = await profileService.updateProfile(payload);
            console.log(
                `Profile updated: ${profile.id} (${profile.name})` +
                `${profile.isDefault ? ' [default]' : ''}`
            );
            return;
        }
        case 'delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('profile delete requires --id');
            }
            const deleted = await profileService.deleteProfile(id);
            console.log(deleted ? `Deleted profile: ${id}` : `Profile not found: ${id}`);
            return;
        }
        case 'apply': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            const projectPath = readArgValue(rest, '--project');
            const agentName = readArgValue(rest, '--agent');
            const mode = readArgValue(rest, '--mode');
            const overwriteAgentsMd = hasFlag(rest, '--overwrite-agents-md');

            if ((id && projectPath) || (!id && !projectPath)) {
                throw new Error('profile apply requires exactly one of --project <path> or --id <id>');
            }

            const result = await profileService.applyProfile({
                id: id || undefined,
                projectPath: projectPath || undefined,
                agentName: agentName || undefined,
                mode: mode || undefined,
                overwriteAgentsMd,
            });

            const sourceLabel = result.usedDefaultFallback ? 'default-fallback' : result.matchedBy;
            console.log(
                `Profile applied: ${result.profile.id} (${result.profile.name}) | ` +
                `target=${result.targetProjectPath} | source=${sourceLabel}`
            );

            if (result.kit.status === 'applied') {
                console.log(
                    `Kit applied: ${result.kit.kitId} -> ${result.targetProjectPath} ` +
                    `(${result.kit.agentName}), skills=${result.kit.syncedSkills}, policy=${result.kit.policyPath}`
                );
            } else {
                console.log(`Kit skipped: ${result.kit.reason}`);
            }

            if (result.provider.status === 'applied') {
                const switchedLabel = result.provider.switched
                    .map((item) => `${item.appType}:${item.providerId}`)
                    .join(', ');
                console.log(`Provider switched: ${switchedLabel}`);
                if (result.provider.skippedApps.length > 0) {
                    console.log(`Provider skipped apps: ${result.provider.skippedApps.join(', ')}`);
                }
            } else {
                console.log(`Provider skipped: ${result.provider.reason || 'not configured'}`);
            }
            return;
        }
        default:
            throw new Error(`Unknown profile subcommand: ${subcommand}`);
    }
}

async function handleKit(commandArgs) {
    const subcommand = commandArgs[0];
    if (!subcommand) {
        throw new Error('Missing kit subcommand. Try: kit policy-list|policy-add|loadout-list|add|apply');
    }

    const service = await loadKitService();

    switch (subcommand) {
        case 'policy-list': {
            const policies = service.listKitPolicies();
            if (policies.length === 0) {
                console.log('No AGENTS.md templates found.');
                return;
            }
            policies.forEach(printKitPolicyRow);
            return;
        }
        case 'policy-add': {
            const rest = commandArgs.slice(1);
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const content = await readContentFromArgs(rest);

            if (!name || !content) {
                throw new Error('kit policy-add requires --name and one of --content / --content-file');
            }

            const policy = service.addKitPolicy({
                name,
                description: description || undefined,
                content,
            });
            console.log(`Policy created: ${policy.id} (${policy.name})`);
            return;
        }
        case 'policy-update': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const content = await readContentFromArgs(rest);

            if (!id) {
                throw new Error('kit policy-update requires --id');
            }

            const policy = service.updateKitPolicy({
                id,
                name: name || undefined,
                description: description || undefined,
                content: content === undefined ? undefined : content,
            });
            console.log(`Policy updated: ${policy.id} (${policy.name})`);
            return;
        }
        case 'policy-delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('kit policy-delete requires --id');
            }
            const deleted = service.deleteKitPolicy(id);
            console.log(deleted ? `Deleted policy: ${id}` : `Policy not found: ${id}`);
            return;
        }
        case 'loadout-list': {
            const loadouts = service.listKitLoadouts();
            if (loadouts.length === 0) {
                console.log('No skills packages found.');
                return;
            }
            loadouts.forEach(printKitLoadoutRow);
            return;
        }
        case 'loadout-add': {
            const rest = commandArgs.slice(1);
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const skillsRaw = readArgValue(rest, '--skills');
            const mode = normalizeKitMode(readArgValue(rest, '--mode'));

            if (!name || !skillsRaw) {
                throw new Error('kit loadout-add requires --name and --skills');
            }

            const skillPaths = parseSkillsArg(skillsRaw);
            const loadout = service.addKitLoadout({
                name,
                description: description || undefined,
                items: skillPaths.map((skillPath, index) => ({
                    skillPath,
                    mode,
                    sortOrder: index,
                })),
            });
            console.log(`Loadout created: ${loadout.id} (${loadout.name})`);
            return;
        }
        case 'loadout-update': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const skillsRaw = readArgValue(rest, '--skills');
            const mode = normalizeKitMode(readArgValue(rest, '--mode'));

            if (!id) {
                throw new Error('kit loadout-update requires --id');
            }

            const items = skillsRaw
                ? parseSkillsArg(skillsRaw).map((skillPath, index) => ({
                    skillPath,
                    mode,
                    sortOrder: index,
                }))
                : undefined;

            const loadout = service.updateKitLoadout({
                id,
                name: name || undefined,
                description: description || undefined,
                items,
            });
            console.log(`Loadout updated: ${loadout.id} (${loadout.name})`);
            return;
        }
        case 'loadout-delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('kit loadout-delete requires --id');
            }
            const deleted = service.deleteKitLoadout(id);
            console.log(deleted ? `Deleted loadout: ${id}` : `Loadout not found: ${id}`);
            return;
        }
        case 'list': {
            const kits = service.listKits();
            if (kits.length === 0) {
                console.log('No kits found.');
                return;
            }
            kits.forEach(printKitRow);
            return;
        }
        case 'add': {
            const rest = commandArgs.slice(1);
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const policyId = readArgValue(rest, '--policy-id');
            const loadoutId = readArgValue(rest, '--loadout-id');

            if (!name || !policyId || !loadoutId) {
                throw new Error('kit add requires --name --policy-id --loadout-id');
            }

            const kit = service.addKit({
                name,
                description: description || undefined,
                policyId,
                loadoutId,
            });
            console.log(`Kit created: ${kit.id} (${kit.name})`);
            return;
        }
        case 'update': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const policyId = readArgValue(rest, '--policy-id');
            const loadoutId = readArgValue(rest, '--loadout-id');

            if (!id) {
                throw new Error('kit update requires --id');
            }

            const kit = service.updateKit({
                id,
                name: name || undefined,
                description: description || undefined,
                policyId: policyId || undefined,
                loadoutId: loadoutId || undefined,
            });
            console.log(`Kit updated: ${kit.id} (${kit.name})`);
            return;
        }
        case 'delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('kit delete requires --id');
            }
            const deleted = service.deleteKit(id);
            console.log(deleted ? `Deleted kit: ${id}` : `Kit not found: ${id}`);
            return;
        }
        case 'apply': {
            const rest = commandArgs.slice(1);
            const kitId = readArgValue(rest, '--id');
            const projectPath = readArgValue(rest, '--project');
            const agentName = readArgValue(rest, '--agent');
            const mode = normalizeKitMode(readArgValue(rest, '--mode'));
            const overwriteAgentsMd = hasFlag(rest, '--overwrite-agents-md');
            const dryRun = hasFlag(rest, '--dry-run');

            if (!kitId || !projectPath || !agentName) {
                throw new Error('kit apply requires --id --project --agent');
            }

            if (dryRun) {
                const preview = await service.previewKitApply({
                    kitId,
                    projectPath,
                    agentName,
                    mode,
                    overwriteAgentsMd,
                });
                printDryRunPreview(preview);
                return;
            }

            const config = await loadConfig();
            const snapshotService = await loadSnapshotService();
            const snapshotPlan = await service.planKitApplySnapshot({
                kitId,
                projectPath,
                agentName,
                mode,
                overwriteAgentsMd,
            });
            const snapshot = await snapshotService.createSnapshot({
                operation: snapshotPlan.operation,
                target: snapshotPlan.target,
                mode: snapshotPlan.mode,
                affectedPaths: snapshotPlan.affectedPaths,
                retention: snapshotService.resolveSnapshotRetention(config.snapshotRetention),
            });
            console.log(`Snapshot created: ${snapshot.id} (paths=${snapshot.affectedPaths.length})`);

            const result = await service.applyKit({
                kitId,
                projectPath,
                agentName,
                mode,
                overwriteAgentsMd,
            });

            const successCount = result.loadoutResults.filter((item) => item.status === 'success').length;
            console.log(
                `Kit applied: ${result.kitId} -> ${result.projectPath} (${result.agentName}), ` +
                `skills=${successCount}, policy=${result.policyPath}`
            );
            return;
        }
        default:
            throw new Error(`Unknown kit subcommand: ${subcommand}`);
    }
}

async function handleProvider(commandArgs) {
    const subcommand = commandArgs[0];
    if (!subcommand) {
        throw new Error('Missing provider subcommand. Try: provider list|add|update|switch|delete|restore|capture|universal-list|universal-add|universal-apply|universal-delete');
    }

    const core = await loadProviderCore();

    switch (subcommand) {
        case 'list': {
            const appType = readArgValue(commandArgs.slice(1), '--app');
            const providers = core.maskProviders(core.listProviders(appType || undefined));
            if (providers.length === 0) {
                console.log('No providers found.');
                return;
            }
            providers.forEach(printProviderRow);
            return;
        }
        case 'add': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            const name = readArgValue(rest, '--name');
            if (!appType || !name) {
                throw new Error('provider add requires --app and --name');
            }
            const config = await readProviderConfigFromArgs(rest);
            if (!config) {
                throw new Error('provider add requires --config-json or --config-file');
            }
            const profile = readProviderProfileArgs(rest, 'api');
            const provider = core.addProvider({
                appType,
                name,
                config: {
                    ...config,
                    _profile: {
                        ...(config._profile || {}),
                        ...profile,
                    },
                },
            });
            console.log(`Provider created: ${provider.id} (${provider.appType} / ${provider.name})`);
            return;
        }
        case 'update': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            const name = readArgValue(rest, '--name');
            if (!id) {
                throw new Error('provider update requires --id');
            }
            const config = await readProviderConfigFromArgs(rest);
            if (name === null && config === undefined) {
                throw new Error('provider update requires at least one of --name / --config-json / --config-file');
            }
            const provider = core.updateProvider({ id, name: name || undefined, config });
            console.log(`Provider updated: ${provider.id} (${provider.name})`);
            return;
        }
        case 'switch': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            const id = readArgValue(rest, '--id');
            if (!appType || !id) {
                throw new Error('provider switch requires --app and --id');
            }
            const result = await core.switchProvider({ appType, providerId: id });
            console.log(
                `Switched ${result.appType}: ${result.switchedFrom || 'none'} -> ${result.switchedTo} (backup #${result.backupId})`
            );
            return;
        }
        case 'delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('provider delete requires --id');
            }
            const deleted = core.deleteProvider(id);
            console.log(deleted ? `Deleted provider: ${id}` : `Provider not found: ${id}`);
            return;
        }
        case 'restore': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            if (!appType) {
                throw new Error('provider restore requires --app');
            }
            const restored = await core.restoreBackup(appType);
            console.log(`Restored ${appType} live config from backup #${restored.id}.`);
            return;
        }
        case 'capture': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            const name = readArgValue(rest, '--name');
            if (!appType || !name) {
                throw new Error('provider capture requires --app and --name');
            }
            const profile = readProviderProfileArgs(rest, 'official');
            const provider = await core.captureProviderFromLive({
                appType,
                name,
                profile,
            });
            console.log(`Provider captured from live config: ${provider.id} (${provider.appType} / ${provider.name})`);
            return;
        }
        case 'universal-list': {
            const universalProviders = core.listUniversalProviders();
            if (universalProviders.length === 0) {
                console.log('No universal providers found.');
                return;
            }
            universalProviders.forEach(printUniversalProviderRow);
            return;
        }
        case 'universal-add': {
            const rest = commandArgs.slice(1);
            const name = readArgValue(rest, '--name');
            const baseUrl = readArgValue(rest, '--base-url');
            const apiKey = readArgValue(rest, '--api-key');
            const websiteUrl = readArgValue(rest, '--website');
            const notes = readArgValue(rest, '--note');

            if (!name || !baseUrl || !apiKey) {
                throw new Error('provider universal-add requires --name, --base-url and --api-key');
            }

            const universalProvider = core.addUniversalProvider({
                name,
                baseUrl,
                apiKey,
                websiteUrl: websiteUrl || undefined,
                notes: notes || undefined,
                apps: readUniversalApps(rest),
                models: readUniversalModels(rest),
            });

            const applied = core.applyUniversalProvider({ id: universalProvider.id });
            console.log(
                `Universal provider created: ${universalProvider.id} (${universalProvider.name}), applied ${applied.length} app providers.`
            );
            return;
        }
        case 'universal-apply': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('provider universal-apply requires --id');
            }
            const applied = core.applyUniversalProvider({ id });
            console.log(`Universal provider applied: ${id} (${applied.length} app providers updated)`);
            return;
        }
        case 'universal-delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('provider universal-delete requires --id');
            }
            const deleted = core.deleteUniversalProvider(id);
            console.log(deleted ? `Deleted universal provider: ${id}` : `Universal provider not found: ${id}`);
            return;
        }
        default:
            throw new Error(`Unknown provider subcommand: ${subcommand}`);
    }
}

async function handleList() {
    const config = await loadConfig();
    const hubPath = expandHome(config.hubPath);

    console.log(`Listing skills in ${hubPath}:`);
    if (!await fse.pathExists(hubPath)) {
        console.log('  (Hub directory does not exist yet)');
        return;
    }

    const items = await fsPromises.readdir(hubPath);
    for (const item of items) {
        const fullPath = path.join(hubPath, item);
        const stat = await fse.stat(fullPath);
        if (stat.isDirectory()) {
            console.log(`  - ${item}`);
        }
    }
}

async function handleScanProjects(commandArgs) {
    const force = hasFlag(commandArgs, '--force');
    const config = await loadConfig();
    const scanner = await loadScanner();

    const configuredRoots = Array.isArray(config.scanRoots)
        ? config.scanRoots
        : [];
    const roots = configuredRoots
        .map((rootPath) => expandHome(rootPath))
        .map((rootPath) => path.resolve(rootPath))
        .filter(Boolean);
    const uniqueRoots = Array.from(new Set(roots));

    if (uniqueRoots.length === 0) {
        console.log('No scan roots configured. Configure scanRoots in ~/.skills-hub/config.json first.');
        return;
    }

    const startedAt = Date.now();
    const projects = await scanner.scanForProjects(uniqueRoots, { force });
    const finishedAt = Date.now();

    console.log(`Started at: ${new Date(startedAt).toISOString()}`);
    console.log(`Finished at: ${new Date(finishedAt).toISOString()}`);
    console.log(`Scanned roots: ${uniqueRoots.length}`);
    console.log(`Projects found: ${projects.length}`);
    console.log(`Duration: ${finishedAt - startedAt}ms`);
    console.log(`Cache file: ${scanner.getProjectScanCachePath()}${force ? ' (force refresh)' : ''}`);

    for (const projectPath of projects) {
        console.log(`- ${projectPath}`);
    }
}

async function handleSync(commandArgs) {
    const targetName = readArgValue(commandArgs, '--target', '-t');
    const allTargets = commandArgs.includes('--all');
    const dryRun = hasFlag(commandArgs, '--dry-run');

    if (!targetName && !allTargets) {
        console.error('Error: specify --target <name> or --all');
        process.exit(1);
    }

    const config = await loadConfig();
    const hubPath = expandHome(config.hubPath);

    if (!await fse.pathExists(hubPath)) {
        console.log('Hub directory empty, nothing to sync.');
        return;
    }

    let targetAgents = [];
    if (allTargets) {
        targetAgents = config.agents.filter((agent) => agent.enabled);
    } else {
        const normalized = targetName.toLowerCase();
        targetAgents = config.agents.filter((agent) => agent.name.toLowerCase().includes(normalized));
    }

    if (targetAgents.length === 0) {
        console.error('No matching agents found to sync to.');
        return;
    }

    const syncService = await loadSyncService();
    const snapshotService = dryRun ? null : await loadSnapshotService();
    const skills = await fsPromises.readdir(hubPath);
    const skillDirectories = [];
    for (const skill of skills) {
        const skillSource = path.join(hubPath, skill);
        const stat = await fse.stat(skillSource);
        if (!stat.isDirectory()) continue;
        skillDirectories.push({
            name: skill,
            sourcePath: skillSource,
        });
    }

    const preview = {
        action: 'sync',
        dryRun: true,
        mode: 'copy',
        targetCount: targetAgents.length,
        skillCount: skillDirectories.length,
        changes: [],
        summary: { total: 0, add: 0, update: 0, delete: 0, link: 0 },
    };

    if (!dryRun) {
        if (skillDirectories.length > 0) {
            const affectedPaths = [];
            for (const agent of targetAgents) {
                const destRoot = expandHome(agent.globalPath);
                for (const skill of skillDirectories) {
                    affectedPaths.push(path.join(destRoot, skill.name));
                }
            }

            const snapshot = await snapshotService.createSnapshot({
                operation: 'sync',
                target: targetAgents.map((agent) => agent.name).join(', '),
                mode: 'copy',
                affectedPaths,
                retention: snapshotService.resolveSnapshotRetention(config.snapshotRetention),
            });
            console.log(`Snapshot created: ${snapshot.id} (paths=${snapshot.affectedPaths.length})`);
        }

        console.log(`Found ${skillDirectories.length} skills in Hub. Syncing to ${targetAgents.length} agents...`);
    }

    for (const agent of targetAgents) {
        const destRoot = expandHome(agent.globalPath);
        if (!dryRun) {
            console.log(`\nSyncing to Agent: ${agent.name} (${destRoot})...`);
        }
        if (!dryRun) {
            await fse.ensureDir(destRoot);
        }

        for (const skill of skillDirectories) {
            try {
                if (dryRun) {
                    const planned = await syncService.previewSkillSync({
                        sourcePath: skill.sourcePath,
                        destParentPath: destRoot,
                        mode: 'copy',
                    });
                    preview.changes.push(...planned.changes);
                } else {
                    const synced = await syncService.syncSkill({
                        sourcePath: skill.sourcePath,
                        destParentPath: destRoot,
                        mode: 'copy',
                    });
                    console.log(`  [OK] ${skill.name} -> ${synced.destination}`);
                }
            } catch (error) {
                console.error(`  [ERR] Failed to sync ${skill.name}:`, error);
            }
        }
    }

    if (dryRun) {
        preview.summary = syncService.summarizeSyncChanges(preview.changes);
        printDryRunPreview(preview);
        return;
    }

    console.log('\nSync complete.');
}

async function handleImport(commandArgs) {
    const branchArg = readArgValue(commandArgs, '--branch', '-b');
    const url = commandArgs.find((arg) => !arg.startsWith('-'));

    if (!url) {
        console.error('Error: Missing URL for import.');
        console.log('Usage: skills-hub import <url> [--branch <branch>]');
        process.exit(1);
    }

    const { repoUrl, repoWebUrl, subdir, skillName, branch } = parseSkillImportUrl(url, branchArg);
    const config = await loadConfig();
    const hubPath = expandHome(config.hubPath);
    const destPath = path.join(hubPath, skillName);

    console.log(`  Repo: ${repoUrl}`);
    console.log(`  Subdir: ${subdir || '(root)'}`);
    console.log(`  Target: ${destPath}`);

    if (await fse.pathExists(destPath)) {
        console.error(`Error: Skill '${skillName}' already exists at ${destPath}`);
        process.exit(1);
    }

    const downloadResult = await downloadRemoteSkill(repoUrl, subdir, destPath, branch);
    const sourceUrl = buildGitSourceUrl(repoWebUrl, downloadResult.resolvedBranch, subdir);
    await attachSkillImportMetadata(destPath, {
        sourceRepo: repoWebUrl,
        sourceUrl,
        sourceSubdir: subdir,
        sourceLastUpdated: downloadResult.lastUpdatedAt,
        importedAt: new Date().toISOString(),
    });

    console.log(`Successfully imported ${skillName} from ${repoWebUrl}!`);
    console.log(`Source last updated: ${downloadResult.lastUpdatedAt}`);
}

function getConfigPath() {
    return path.join(os.homedir(), '.skills-hub', 'config.json');
}

function buildDefaultAgents() {
    return [
        { name: 'Antigravity', globalPath: path.join(os.homedir(), '.gemini/antigravity/skills'), projectPath: '.agent/skills', enabled: true, isCustom: false },
        { name: 'Claude Code', globalPath: path.join(os.homedir(), '.claude/skills'), projectPath: '.claude/skills', enabled: true, isCustom: false },
        { name: 'Cursor', globalPath: path.join(os.homedir(), '.cursor/skills'), projectPath: '.cursor/skills', enabled: true, isCustom: false },
        { name: 'OpenCode', globalPath: path.join(os.homedir(), '.config/opencode/skill'), projectPath: '.opencode/skill', enabled: false, isCustom: false },
        { name: 'Codex', globalPath: path.join(os.homedir(), '.codex/skills'), projectPath: '.codex/skills', enabled: false, isCustom: false },
        { name: 'Amp', globalPath: path.join(os.homedir(), '.config/agents/skills'), projectPath: '.agents/skills', enabled: false, isCustom: false },
        { name: 'Kilo Code', globalPath: path.join(os.homedir(), '.kilocode/skills'), projectPath: '.kilocode/skills', enabled: false, isCustom: false },
        { name: 'Roo Code', globalPath: path.join(os.homedir(), '.roo/skills'), projectPath: '.roo/skills', enabled: false, isCustom: false },
        { name: 'Goose', globalPath: path.join(os.homedir(), '.config/goose/skills'), projectPath: '.goose/skills', enabled: false, isCustom: false },
        { name: 'Gemini CLI', globalPath: path.join(os.homedir(), '.gemini/skills'), projectPath: '.gemini/skills', enabled: false, isCustom: false },
        { name: 'GitHub Copilot', globalPath: path.join(os.homedir(), '.copilot/skills'), projectPath: '.github/skills', enabled: false, isCustom: false },
        { name: 'Clawdbot', globalPath: path.join(os.homedir(), '.clawdbot/skills'), projectPath: 'skills', enabled: false, isCustom: false },
        { name: 'Droid', globalPath: path.join(os.homedir(), '.factory/skills'), projectPath: '.factory/skills', enabled: false, isCustom: false },
        { name: 'Windsurf', globalPath: path.join(os.homedir(), '.codeium/windsurf/skills'), projectPath: '.windsurf/skills', enabled: false, isCustom: false },
        { name: 'Trae', globalPath: path.join(os.homedir(), '.trae/skills'), projectPath: '.trae/skills', enabled: false, isCustom: false },
        { name: 'Qoder', globalPath: path.join(os.homedir(), '.qoder/skills'), projectPath: '.qoder/skills', enabled: false, isCustom: false },
    ];
}

function buildDefaultConfig() {
    return {
        hubPath: path.join(os.homedir(), 'skills-hub'),
        projects: [],
        scanRoots: [path.join(os.homedir(), 'workspace')],
        snapshotRetention: 20,
        agents: buildDefaultAgents(),
    };
}

function normalizeSnapshotRetentionValue(value, fallback = 20) {
    const parsed = Number.parseInt(String(value ?? '').trim(), 10);
    if (!Number.isInteger(parsed) || parsed <= 0) {
        return fallback;
    }
    return parsed;
}

async function loadConfig() {
    try {
        const defaultConfig = buildDefaultConfig();
        const content = await fsPromises.readFile(getConfigPath(), 'utf-8');
        if (!content.trim()) return defaultConfig;
        const userConfig = JSON.parse(content);

        const mergedAgents = buildDefaultAgents();
        const userAgents = userConfig.agents || [];

        mergedAgents.forEach((agent, index) => {
            const userAgent = userAgents.find((ua) => ua.name === agent.name);
            if (userAgent) {
                mergedAgents[index] = {
                    ...agent,
                    enabled: userAgent.enabled,
                    projectPath: userAgent.projectPath,
                    globalPath: userAgent.globalPath,
                };
            }
        });

        const customAgents = userAgents.filter((ua) => ua.isCustom);

        return {
            ...defaultConfig,
            ...userConfig,
            snapshotRetention: normalizeSnapshotRetentionValue(
                userConfig.snapshotRetention,
                defaultConfig.snapshotRetention
            ),
            agents: [...mergedAgents, ...customAgents],
        };
    } catch {
        return buildDefaultConfig();
    }
}

async function resolveDefaultBranch(git) {
    try {
        const result = await git.listRemote(['--symref', 'origin', 'HEAD']);
        const match = result.match(/ref:\s+refs\/heads\/([^\s]+)\s+HEAD/);
        return match ? match[1] : null;
    } catch {
        return null;
    }
}

async function downloadRemoteSkill(repoUrl, subdir, destPath, branch) {
    const tempDir = await fsPromises.mkdtemp(path.join(os.tmpdir(), 'skills-hub-import-'));
    const git = simpleGit(tempDir);

    try {
        await git.init();
        await git.addRemote('origin', repoUrl);
        await git.addConfig('core.sparseCheckout', 'true');

        if (subdir) {
            await fsPromises.writeFile(path.join(tempDir, '.git/info/sparse-checkout'), `${subdir}\n`, 'utf-8');
        } else {
            await fsPromises.writeFile(path.join(tempDir, '.git/info/sparse-checkout'), '*\n', 'utf-8');
        }

        const requestedBranch = branch ? branch.trim() : '';
        const defaultBranch = requestedBranch ? null : await resolveDefaultBranch(git);
        const branchesToTry = requestedBranch
            ? [requestedBranch]
            : defaultBranch
                ? [defaultBranch]
                : ['main', 'master'];

        let pulledBranch = '';
        let lastError;
        for (const candidate of branchesToTry) {
            try {
                await git.pull('origin', candidate, { '--depth': 1 });
                pulledBranch = candidate;
                break;
            } catch (error) {
                lastError = error;
            }
        }

        if (!pulledBranch) {
            throw lastError instanceof Error
                ? lastError
                : new Error('Failed to resolve default branch for remote repository.');
        }

        const logArgs = ['log', '-1', '--format=%cI'];
        if (subdir) {
            logArgs.push('--', subdir);
        }
        let lastUpdatedAt = new Date().toISOString();
        try {
            const lastUpdatedAtRaw = await git.raw(logArgs);
            lastUpdatedAt = lastUpdatedAtRaw.trim() || lastUpdatedAt;
        } catch {
            // Keep fallback timestamp to avoid import failure on metadata lookup issues.
        }

        const sourceContentPath = subdir ? path.join(tempDir, subdir) : tempDir;

        if (!await fse.pathExists(sourceContentPath)) {
            throw new Error(`Directory '${subdir}' not found in remote repository.`);
        }

        await fse.ensureDir(path.dirname(destPath));
        await fse.copy(sourceContentPath, destPath);
        return {
            resolvedBranch: pulledBranch,
            lastUpdatedAt,
        };
    } finally {
        await fse.remove(tempDir);
    }
}
