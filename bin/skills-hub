#!/usr/bin/env node
'use strict';

const fsPromises = require('fs/promises');
const fse = require('fs-extra');
const path = require('path');
const os = require('os');
const simpleGit = require('simple-git');
const matter = require('gray-matter');

const args = process.argv.slice(2);
const commandAliases = new Map([
    ['ls', 'list'],
    ['rm', 'remove'],
]);
const commands = new Set(['import', 'list', 'ls', 'remove', 'rm', 'sync', 'provider', 'kit']);
const flagsWithValues = new Set([
    '-b',
    '--branch',
    '--target',
    '-t',
    '--app',
    '--id',
    '--name',
    '--note',
    '--website',
    '--account-name',
    '--vendor-key',
    '--base-url',
    '--api-key',
    '--apps',
    '--claude-model',
    '--codex-model',
    '--gemini-model',
    '--config-json',
    '--config-file',
    '--policy-id',
    '--loadout-id',
    '--description',
    '--skills',
    '--project',
    '--agent',
    '-a',
    '--mode',
    '--content',
    '--content-file',
]);
let providerCorePromise = null;
let kitServicePromise = null;

async function main() {
    let command = null;
    let commandIndex = -1;

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (arg.startsWith('-')) {
            // Check if it's a flag=value style
            if (arg.includes('=')) continue;

            // Check if it's a flag that takes a value next
            if (flagsWithValues.has(arg)) {
                i++; // Skip the next argument (the value)
            }
        } else {
            // Found the first non-flag argument, closest thing to a command
            command = arg;
            commandIndex = i;
            break;
        }
    }

    if (args.includes('--help') || args.includes('-h')) {
        printHelp();
        process.exit(0);
    }

    if (args.includes('--version') || args.includes('-v') || args.includes('-V')) {
        const pkg = require(path.join(__dirname, '..', 'package.json'));
        console.log(pkg.version);
        process.exit(0);
    }

    if (command && !commands.has(command)) {
        console.error(`Unknown command: ${command}`);
        printHelp();
        process.exit(1);
    }

    if (!command) {
        printHelp();
        process.exit(1);
    }

    const normalizedCommand = commandAliases.get(command) || command;
    const commandArgs = args.slice(commandIndex + 1);
    await runCommand(normalizedCommand, commandArgs);
}

function printHelp() {
    console.log(`Usage:
  skills-hub <command> [options]

Commands:
  import <url> [options]             Import a skill from a git repository
  list [options]                     List installed skills (alias: ls)
  remove [skills...] [options]       Remove installed skills (alias: rm)
  sync --all | --target <name>       Sync hub skills to agent targets
  provider <subcommand>              Manage provider profiles and switching
  kit <subcommand>                   Manage AGENTS templates, loadouts, and kits

Import options:
  -b, --branch <branch>              Use branch when importing from Git
  -l, --list                         List installable skills in remote source only
  -g, --global                       Install to global scope (default: current project)
  -a, --agent <name>                 Install to target agent(s), repeatable or comma-separated
  --copy                             Copy files instead of symbolic links (default: symlink)
  -y, --yes                          Overwrite conflicting destinations without prompt

List options:
  -g, --global                       Show global installation scope
  -a, --agent <name>                 Filter by target agent(s)
  --hub                              Show skills in hub storage instead of installation view

Remove options:
  -g, --global                       Remove from global installation scope
  -a, --agent <name>                 Remove only from target agent(s)
  --all                              Remove all installed skills in selected scope
  --hub                              Remove from hub storage only

Provider subcommands:
  provider list [--app <app>]                                List providers
  provider add --app <app> --name <name> --config-json <json>
  provider add --app <app> --name <name> --config-file <path>
  provider update --id <id> [--name <name>] [--config-json <json>|--config-file <path>]
  provider switch --app <app> --id <providerId>              Switch current provider
  provider delete --id <providerId>                          Delete a provider
  provider restore --app <app>                               Restore latest live backup
  provider capture --app <app> --name <name>                 Capture current live config as provider
  provider universal-list                                     List universal providers
  provider universal-add --name <name> --base-url <url> --api-key <key> [--apps claude,codex,gemini]
  provider universal-apply --id <universalProviderId>        Apply universal provider to enabled apps
  provider universal-delete --id <universalProviderId>       Delete universal provider

Kit subcommands:
  kit policy-list
  kit policy-add --name <name> [--description <text>] (--content <text> | --content-file <path>)
  kit policy-update --id <id> [--name <name>] [--description <text>] [--content <text>|--content-file <path>]
  kit policy-delete --id <id>
  kit loadout-list
  kit loadout-add --name <name> --skills <path1,path2,...> [--description <text>] [--mode copy|link]
  kit loadout-update --id <id> [--name <name>] [--description <text>] [--skills <path1,path2,...>] [--mode copy|link]
  kit loadout-delete --id <id>
  kit list
  kit add --name <name> --policy-id <id> --loadout-id <id> [--description <text>]
  kit update --id <id> [--name <name>] [--policy-id <id>] [--loadout-id <id>] [--description <text>]
  kit delete --id <id>
  kit apply --id <id> --project <path> --agent <name> [--mode copy|link] [--overwrite-agents-md]

  -v, --version       Show version number
  -h, --help          Show this help message
`);
}

function readArgValue(argv, flag, shortFlag) {
    const index = argv.indexOf(flag);
    if (index !== -1 && index + 1 < argv.length) {
        return argv[index + 1];
    }

    if (shortFlag) {
        const shortIndex = argv.indexOf(shortFlag);
        if (shortIndex !== -1 && shortIndex + 1 < argv.length) {
            return argv[shortIndex + 1];
        }
    }

    const withEq = argv.find((arg) => arg.startsWith(`${flag}=`));
    if (withEq) {
        return withEq.split('=').slice(1).join('=');
    }

    return null;
}

function expandHome(inputPath) {
    if (!inputPath) return inputPath;
    if (inputPath.startsWith('~')) {
        return path.join(os.homedir(), inputPath.slice(1));
    }
    return inputPath;
}

function normalizeRepoWebUrl(url) {
    return url.trim().replace(/\/$/, '').replace(/\.git$/, '');
}

function parseSkillImportUrl(url, preferredBranch) {
    const input = url.trim();
    if (!input) {
        throw new Error('Missing URL for import.');
    }

    let repoWebUrl = '';
    let branch = preferredBranch ? preferredBranch.trim() : '';
    let subdir = '';

    if (input.includes('/tree/')) {
        const [base, restRaw = ''] = input.split('/tree/', 2);
        repoWebUrl = normalizeRepoWebUrl(base);

        const rest = restRaw.replace(/^\/+/, '');
        if (rest) {
            const parts = rest.split('/').filter(Boolean);
            if (!branch && parts.length > 0) {
                branch = parts[0];
            }
            if (parts.length > 1) {
                subdir = parts.slice(1).join('/');
            }
        }
    } else {
        repoWebUrl = normalizeRepoWebUrl(input);
    }

    const skillName = subdir ? path.basename(subdir) : path.basename(repoWebUrl);
    if (!repoWebUrl || !skillName) {
        throw new Error('Invalid skill import URL.');
    }

    return {
        repoUrl: `${repoWebUrl}.git`,
        repoWebUrl,
        branch: branch || undefined,
        subdir,
        skillName,
    };
}

function buildGitSourceUrl(repoWebUrl, branch, subdir) {
    const normalized = normalizeRepoWebUrl(repoWebUrl);
    if (!branch) {
        return normalized;
    }
    if (subdir) {
        return `${normalized}/tree/${branch}/${subdir}`;
    }
    return `${normalized}/tree/${branch}`;
}

async function attachSkillImportMetadata(skillDirPath, metadata) {
    const skillMdPath = path.join(skillDirPath, 'SKILL.md');
    if (!await fse.pathExists(skillMdPath)) {
        return;
    }

    const rawContent = await fsPromises.readFile(skillMdPath, 'utf-8');
    const parsed = matter(rawContent);
    const { source_branch: _ignoredSourceBranch, ...restFrontmatter } = parsed.data || {};
    const nextFrontmatter = {
        ...restFrontmatter,
        source_repo: metadata.sourceRepo,
        source_url: metadata.sourceUrl,
        source_subdir: metadata.sourceSubdir || '/',
        source_last_updated: metadata.sourceLastUpdated,
        imported_at: metadata.importedAt,
    };

    const nextRawContent = matter.stringify(parsed.content, nextFrontmatter);
    await fsPromises.writeFile(skillMdPath, nextRawContent, 'utf-8');
}

async function runCommand(commandName, commandArgs) {
    switch (commandName) {
        case 'import':
            await handleImport(commandArgs);
            return;
        case 'list':
            await handleList(commandArgs);
            return;
        case 'remove':
            await handleRemove(commandArgs);
            return;
        case 'sync':
            await handleSync(commandArgs);
            return;
        case 'provider':
            await handleProvider(commandArgs);
            return;
        case 'kit':
            await handleKit(commandArgs);
            return;
        default:
            console.error(`Unknown command: ${commandName}`);
            process.exit(1);
    }
}

function loadProviderCore() {
    if (!providerCorePromise) {
        providerCorePromise = import('../lib/core/provider-core.mjs');
    }
    return providerCorePromise;
}

function loadKitService() {
    if (!kitServicePromise) {
        kitServicePromise = import('../lib/services/kit-service.mjs');
    }
    return kitServicePromise;
}

function parseJsonArg(jsonText) {
    try {
        const parsed = JSON.parse(jsonText);
        if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {
            throw new Error('must be a JSON object');
        }
        return parsed;
    } catch (error) {
        throw new Error(`Invalid JSON config: ${error.message || error}`);
    }
}

async function readProviderConfigFromArgs(commandArgs) {
    const configJson = readArgValue(commandArgs, '--config-json');
    const configFile = readArgValue(commandArgs, '--config-file');

    if (configJson && configFile) {
        throw new Error('Use either --config-json or --config-file, not both.');
    }

    if (configJson) {
        return parseJsonArg(configJson);
    }

    if (configFile) {
        const resolved = path.resolve(configFile);
        const raw = await fsPromises.readFile(resolved, 'utf-8');
        return parseJsonArg(raw);
    }

    return undefined;
}

function readProviderProfileArgs(commandArgs, defaultKind = 'api') {
    const note = readArgValue(commandArgs, '--note');
    const website = readArgValue(commandArgs, '--website');
    const accountName = readArgValue(commandArgs, '--account-name');
    const vendorKey = readArgValue(commandArgs, '--vendor-key');

    return {
        kind: defaultKind,
        note: note || undefined,
        website: website || undefined,
        accountName: accountName || undefined,
        vendorKey: vendorKey || undefined,
    };
}

function hasFlag(argv, flag) {
    return argv.includes(flag);
}

function parseCsvValues(rawValue) {
    if (!rawValue) return [];
    return rawValue
        .split(',')
        .map((value) => value.trim())
        .filter(Boolean);
}

function appendUniqueValues(target, values) {
    for (const value of values) {
        if (!target.includes(value)) {
            target.push(value);
        }
    }
}

function parseAgentOptionValues(commandArgs, optionName = 'option') {
    const agents = [];

    for (let i = 0; i < commandArgs.length; i++) {
        const arg = commandArgs[i];
        if (arg === '--agent' || arg === '-a') {
            const next = commandArgs[i + 1];
            if (!next || next.startsWith('-')) {
                throw new Error(`${optionName} requires a value for --agent/-a.`);
            }
            appendUniqueValues(agents, parseCsvValues(next));
            i++;
            continue;
        }

        if (arg.startsWith('--agent=')) {
            const values = parseCsvValues(arg.split('=').slice(1).join('='));
            if (values.length === 0) {
                throw new Error(`${optionName} requires a value for --agent.`);
            }
            appendUniqueValues(agents, values);
            continue;
        }

        if (arg.startsWith('-a=')) {
            const values = parseCsvValues(arg.split('=').slice(1).join('='));
            if (values.length === 0) {
                throw new Error(`${optionName} requires a value for -a.`);
            }
            appendUniqueValues(agents, values);
        }
    }

    return agents;
}

function parseScopeArgs(commandArgs, commandName, extraBooleanFlags = new Set()) {
    const parsed = {
        useGlobal: false,
        useHub: false,
        agents: [],
        positional: [],
    };

    for (let i = 0; i < commandArgs.length; i++) {
        const arg = commandArgs[i];

        if (arg === '--global' || arg === '-g') {
            parsed.useGlobal = true;
            continue;
        }

        if (arg === '--hub') {
            parsed.useHub = true;
            continue;
        }

        if (arg === '--agent' || arg === '-a') {
            const next = commandArgs[i + 1];
            if (!next || next.startsWith('-')) {
                throw new Error(`${commandName}: missing value for --agent/-a.`);
            }
            appendUniqueValues(parsed.agents, parseCsvValues(next));
            i++;
            continue;
        }

        if (arg.startsWith('--agent=')) {
            const values = parseCsvValues(arg.split('=').slice(1).join('='));
            if (values.length === 0) {
                throw new Error(`${commandName}: missing value for --agent.`);
            }
            appendUniqueValues(parsed.agents, values);
            continue;
        }

        if (arg.startsWith('-a=')) {
            const values = parseCsvValues(arg.split('=').slice(1).join('='));
            if (values.length === 0) {
                throw new Error(`${commandName}: missing value for -a.`);
            }
            appendUniqueValues(parsed.agents, values);
            continue;
        }

        if (extraBooleanFlags.has(arg)) {
            continue;
        }

        if (arg.startsWith('-')) {
            throw new Error(`${commandName}: unknown option ${arg}`);
        }

        parsed.positional.push(arg);
    }

    if (parsed.useHub && (parsed.useGlobal || parsed.agents.length > 0)) {
        throw new Error(`${commandName}: --hub cannot be combined with --global or --agent.`);
    }

    return parsed;
}

function resolveAgentScopePath(agent, useGlobal, cwdPath = process.cwd()) {
    const configuredPath = useGlobal ? agent.globalPath : agent.projectPath;
    const expandedPath = expandHome(configuredPath);

    if (useGlobal || path.isAbsolute(expandedPath)) {
        return expandedPath;
    }

    return path.join(cwdPath, expandedPath);
}

function matchAgentsBySelectors(agents, selectors) {
    const normalizedSelectors = selectors.map((value) => value.trim().toLowerCase()).filter(Boolean);

    if (normalizedSelectors.length === 0) {
        return agents.filter((agent) => agent.enabled);
    }

    const matched = [];
    for (const selector of normalizedSelectors) {
        const candidates = agents.filter((agent) => {
            const lowerName = String(agent.name || '').toLowerCase();
            return lowerName === selector || lowerName.includes(selector);
        });

        for (const candidate of candidates) {
            if (!matched.some((item) => item.name === candidate.name)) {
                matched.push(candidate);
            }
        }
    }

    return matched;
}

async function readSkillNamesUnderRoot(rootPath) {
    if (!await fse.pathExists(rootPath)) {
        return [];
    }

    const entries = await fsPromises.readdir(rootPath);
    const skills = [];
    for (const entry of entries) {
        const fullPath = path.join(rootPath, entry);
        const stat = await fse.stat(fullPath).catch(() => null);
        if (!stat) continue;
        if (stat.isDirectory()) {
            skills.push(entry);
        }
    }

    return skills.sort((a, b) => a.localeCompare(b));
}

function isInteractiveTerminal() {
    return Boolean(process.stdin.isTTY && process.stdout.isTTY);
}

async function promptYesNo(message) {
    const readline = require('readline');
    return new Promise((resolve) => {
        const rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
        });

        rl.question(`${message} [y/N]: `, (answer) => {
            rl.close();
            const normalized = String(answer || '').trim().toLowerCase();
            resolve(normalized === 'y' || normalized === 'yes');
        });
    });
}

async function syncSkillToTarget(sourcePath, destPath, syncMode) {
    await fse.ensureDir(path.dirname(destPath));
    await fse.remove(destPath);

    if (syncMode === 'link') {
        await fse.ensureSymlink(sourcePath, destPath);
        return;
    }

    await fse.copy(sourcePath, destPath, { overwrite: true });
}

function parseImportArgs(commandArgs) {
    const parsed = {
        url: '',
        branch: readArgValue(commandArgs, '--branch', '-b') || undefined,
        listOnly: hasFlag(commandArgs, '--list') || hasFlag(commandArgs, '-l'),
        useGlobal: hasFlag(commandArgs, '--global') || hasFlag(commandArgs, '-g'),
        copyMode: hasFlag(commandArgs, '--copy'),
        autoYes: hasFlag(commandArgs, '--yes') || hasFlag(commandArgs, '-y'),
        agents: parseAgentOptionValues(commandArgs, 'import'),
    };

    const positional = [];
    for (let i = 0; i < commandArgs.length; i++) {
        const arg = commandArgs[i];
        if (arg === '--branch' || arg === '-b' || arg === '--agent' || arg === '-a') {
            i++;
            continue;
        }
        if (arg.startsWith('--branch=')) continue;
        if (arg.startsWith('--agent=')) continue;
        if (arg.startsWith('-a=')) continue;
        if (arg === '--list' || arg === '-l' || arg === '--global' || arg === '-g' || arg === '--copy' || arg === '--yes' || arg === '-y') {
            continue;
        }
        if (arg.startsWith('-')) {
            throw new Error(`Unknown import option: ${arg}`);
        }
        positional.push(arg);
    }

    if (positional.length === 0) {
        throw new Error('Error: Missing URL for import.');
    }

    if (positional.length > 1) {
        throw new Error(`Unexpected extra import arguments: ${positional.slice(1).join(' ')}`);
    }

    parsed.url = positional[0];
    return parsed;
}

function normalizeKitMode(modeRaw) {
    if (!modeRaw) return 'copy';
    const normalized = String(modeRaw).trim().toLowerCase();
    if (normalized === 'copy' || normalized === 'link') {
        return normalized;
    }
    throw new Error(`Invalid --mode value: ${modeRaw}. Use copy or link.`);
}

function parseSkillsArg(skillsRaw) {
    if (!skillsRaw || !skillsRaw.trim()) {
        throw new Error('Missing --skills value.');
    }

    const skillPaths = skillsRaw
        .split(',')
        .map((entry) => entry.trim())
        .filter(Boolean);

    if (skillPaths.length === 0) {
        throw new Error('At least one skill path is required in --skills.');
    }

    return Array.from(new Set(skillPaths));
}

async function readContentFromArgs(commandArgs) {
    const content = readArgValue(commandArgs, '--content');
    const contentFile = readArgValue(commandArgs, '--content-file');

    if (content && contentFile) {
        throw new Error('Use either --content or --content-file, not both.');
    }

    if (contentFile) {
        const resolved = path.resolve(contentFile);
        return fsPromises.readFile(resolved, 'utf-8');
    }

    if (content) {
        return content;
    }

    return undefined;
}

function readUniversalApps(commandArgs) {
    const raw = readArgValue(commandArgs, '--apps');
    if (!raw) {
        return {
            claude: true,
            codex: true,
            gemini: true,
        };
    }

    const set = new Set(
        raw
            .split(',')
            .map((item) => item.trim().toLowerCase())
            .filter(Boolean)
    );

    return {
        claude: set.has('claude'),
        codex: set.has('codex'),
        gemini: set.has('gemini'),
    };
}

function readUniversalModels(commandArgs) {
    const claudeModel = readArgValue(commandArgs, '--claude-model');
    const codexModel = readArgValue(commandArgs, '--codex-model');
    const geminiModel = readArgValue(commandArgs, '--gemini-model');

    return {
        claude: { model: claudeModel || undefined },
        codex: { model: codexModel || undefined },
        gemini: { model: geminiModel || undefined },
    };
}

function printProviderRow(provider) {
    const currentLabel = provider.isCurrent ? ' (current)' : '';
    console.log(`- ${provider.id} | ${provider.appType} | ${provider.name}${currentLabel}`);
}

function printUniversalProviderRow(provider) {
    const enabledApps = ['claude', 'codex', 'gemini'].filter((app) => provider.apps?.[app]).join(',');
    console.log(`- ${provider.id} | ${provider.name} | ${provider.baseUrl} | apps=${enabledApps || 'none'}`);
}

function printKitPolicyRow(policy) {
    console.log(`- ${policy.id} | ${policy.name}${policy.description ? ` | ${policy.description}` : ''}`);
}

function printKitLoadoutRow(loadout) {
    console.log(`- ${loadout.id} | ${loadout.name} | skills=${loadout.items.length}`);
}

function printKitRow(kit) {
    console.log(`- ${kit.id} | ${kit.name} | policy=${kit.policyId} | loadout=${kit.loadoutId}`);
}

async function handleKit(commandArgs) {
    const subcommand = commandArgs[0];
    if (!subcommand) {
        throw new Error('Missing kit subcommand. Try: kit policy-list|policy-add|loadout-list|add|apply');
    }

    const service = await loadKitService();

    switch (subcommand) {
        case 'policy-list': {
            const policies = service.listKitPolicies();
            if (policies.length === 0) {
                console.log('No AGENTS.md templates found.');
                return;
            }
            policies.forEach(printKitPolicyRow);
            return;
        }
        case 'policy-add': {
            const rest = commandArgs.slice(1);
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const content = await readContentFromArgs(rest);

            if (!name || !content) {
                throw new Error('kit policy-add requires --name and one of --content / --content-file');
            }

            const policy = service.addKitPolicy({
                name,
                description: description || undefined,
                content,
            });
            console.log(`Policy created: ${policy.id} (${policy.name})`);
            return;
        }
        case 'policy-update': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const content = await readContentFromArgs(rest);

            if (!id) {
                throw new Error('kit policy-update requires --id');
            }

            const policy = service.updateKitPolicy({
                id,
                name: name || undefined,
                description: description || undefined,
                content: content === undefined ? undefined : content,
            });
            console.log(`Policy updated: ${policy.id} (${policy.name})`);
            return;
        }
        case 'policy-delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('kit policy-delete requires --id');
            }
            const deleted = service.deleteKitPolicy(id);
            console.log(deleted ? `Deleted policy: ${id}` : `Policy not found: ${id}`);
            return;
        }
        case 'loadout-list': {
            const loadouts = service.listKitLoadouts();
            if (loadouts.length === 0) {
                console.log('No skills packages found.');
                return;
            }
            loadouts.forEach(printKitLoadoutRow);
            return;
        }
        case 'loadout-add': {
            const rest = commandArgs.slice(1);
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const skillsRaw = readArgValue(rest, '--skills');
            const mode = normalizeKitMode(readArgValue(rest, '--mode'));

            if (!name || !skillsRaw) {
                throw new Error('kit loadout-add requires --name and --skills');
            }

            const skillPaths = parseSkillsArg(skillsRaw);
            const loadout = service.addKitLoadout({
                name,
                description: description || undefined,
                items: skillPaths.map((skillPath, index) => ({
                    skillPath,
                    mode,
                    sortOrder: index,
                })),
            });
            console.log(`Loadout created: ${loadout.id} (${loadout.name})`);
            return;
        }
        case 'loadout-update': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const skillsRaw = readArgValue(rest, '--skills');
            const mode = normalizeKitMode(readArgValue(rest, '--mode'));

            if (!id) {
                throw new Error('kit loadout-update requires --id');
            }

            const items = skillsRaw
                ? parseSkillsArg(skillsRaw).map((skillPath, index) => ({
                    skillPath,
                    mode,
                    sortOrder: index,
                }))
                : undefined;

            const loadout = service.updateKitLoadout({
                id,
                name: name || undefined,
                description: description || undefined,
                items,
            });
            console.log(`Loadout updated: ${loadout.id} (${loadout.name})`);
            return;
        }
        case 'loadout-delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('kit loadout-delete requires --id');
            }
            const deleted = service.deleteKitLoadout(id);
            console.log(deleted ? `Deleted loadout: ${id}` : `Loadout not found: ${id}`);
            return;
        }
        case 'list': {
            const kits = service.listKits();
            if (kits.length === 0) {
                console.log('No kits found.');
                return;
            }
            kits.forEach(printKitRow);
            return;
        }
        case 'add': {
            const rest = commandArgs.slice(1);
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const policyId = readArgValue(rest, '--policy-id');
            const loadoutId = readArgValue(rest, '--loadout-id');

            if (!name || !policyId || !loadoutId) {
                throw new Error('kit add requires --name --policy-id --loadout-id');
            }

            const kit = service.addKit({
                name,
                description: description || undefined,
                policyId,
                loadoutId,
            });
            console.log(`Kit created: ${kit.id} (${kit.name})`);
            return;
        }
        case 'update': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const policyId = readArgValue(rest, '--policy-id');
            const loadoutId = readArgValue(rest, '--loadout-id');

            if (!id) {
                throw new Error('kit update requires --id');
            }

            const kit = service.updateKit({
                id,
                name: name || undefined,
                description: description || undefined,
                policyId: policyId || undefined,
                loadoutId: loadoutId || undefined,
            });
            console.log(`Kit updated: ${kit.id} (${kit.name})`);
            return;
        }
        case 'delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('kit delete requires --id');
            }
            const deleted = service.deleteKit(id);
            console.log(deleted ? `Deleted kit: ${id}` : `Kit not found: ${id}`);
            return;
        }
        case 'apply': {
            const rest = commandArgs.slice(1);
            const kitId = readArgValue(rest, '--id');
            const projectPath = readArgValue(rest, '--project');
            const agentName = readArgValue(rest, '--agent');
            const mode = normalizeKitMode(readArgValue(rest, '--mode'));
            const overwriteAgentsMd = hasFlag(rest, '--overwrite-agents-md');

            if (!kitId || !projectPath || !agentName) {
                throw new Error('kit apply requires --id --project --agent');
            }

            const result = await service.applyKit({
                kitId,
                projectPath,
                agentName,
                mode,
                overwriteAgentsMd,
            });

            const successCount = result.loadoutResults.filter((item) => item.status === 'success').length;
            console.log(
                `Kit applied: ${result.kitId} -> ${result.projectPath} (${result.agentName}), ` +
                `skills=${successCount}, policy=${result.policyPath}`
            );
            return;
        }
        default:
            throw new Error(`Unknown kit subcommand: ${subcommand}`);
    }
}

async function handleProvider(commandArgs) {
    const subcommand = commandArgs[0];
    if (!subcommand) {
        throw new Error('Missing provider subcommand. Try: provider list|add|update|switch|delete|restore|capture|universal-list|universal-add|universal-apply|universal-delete');
    }

    const core = await loadProviderCore();

    switch (subcommand) {
        case 'list': {
            const appType = readArgValue(commandArgs.slice(1), '--app');
            const providers = core.maskProviders(core.listProviders(appType || undefined));
            if (providers.length === 0) {
                console.log('No providers found.');
                return;
            }
            providers.forEach(printProviderRow);
            return;
        }
        case 'add': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            const name = readArgValue(rest, '--name');
            if (!appType || !name) {
                throw new Error('provider add requires --app and --name');
            }
            const config = await readProviderConfigFromArgs(rest);
            if (!config) {
                throw new Error('provider add requires --config-json or --config-file');
            }
            const profile = readProviderProfileArgs(rest, 'api');
            const provider = core.addProvider({
                appType,
                name,
                config: {
                    ...config,
                    _profile: {
                        ...(config._profile || {}),
                        ...profile,
                    },
                },
            });
            console.log(`Provider created: ${provider.id} (${provider.appType} / ${provider.name})`);
            return;
        }
        case 'update': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            const name = readArgValue(rest, '--name');
            if (!id) {
                throw new Error('provider update requires --id');
            }
            const config = await readProviderConfigFromArgs(rest);
            if (name === null && config === undefined) {
                throw new Error('provider update requires at least one of --name / --config-json / --config-file');
            }
            const provider = core.updateProvider({ id, name: name || undefined, config });
            console.log(`Provider updated: ${provider.id} (${provider.name})`);
            return;
        }
        case 'switch': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            const id = readArgValue(rest, '--id');
            if (!appType || !id) {
                throw new Error('provider switch requires --app and --id');
            }
            const result = await core.switchProvider({ appType, providerId: id });
            console.log(
                `Switched ${result.appType}: ${result.switchedFrom || 'none'} -> ${result.switchedTo} (backup #${result.backupId})`
            );
            return;
        }
        case 'delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('provider delete requires --id');
            }
            const deleted = core.deleteProvider(id);
            console.log(deleted ? `Deleted provider: ${id}` : `Provider not found: ${id}`);
            return;
        }
        case 'restore': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            if (!appType) {
                throw new Error('provider restore requires --app');
            }
            const restored = await core.restoreBackup(appType);
            console.log(`Restored ${appType} live config from backup #${restored.id}.`);
            return;
        }
        case 'capture': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            const name = readArgValue(rest, '--name');
            if (!appType || !name) {
                throw new Error('provider capture requires --app and --name');
            }
            const profile = readProviderProfileArgs(rest, 'official');
            const provider = await core.captureProviderFromLive({
                appType,
                name,
                profile,
            });
            console.log(`Provider captured from live config: ${provider.id} (${provider.appType} / ${provider.name})`);
            return;
        }
        case 'universal-list': {
            const universalProviders = core.listUniversalProviders();
            if (universalProviders.length === 0) {
                console.log('No universal providers found.');
                return;
            }
            universalProviders.forEach(printUniversalProviderRow);
            return;
        }
        case 'universal-add': {
            const rest = commandArgs.slice(1);
            const name = readArgValue(rest, '--name');
            const baseUrl = readArgValue(rest, '--base-url');
            const apiKey = readArgValue(rest, '--api-key');
            const websiteUrl = readArgValue(rest, '--website');
            const notes = readArgValue(rest, '--note');

            if (!name || !baseUrl || !apiKey) {
                throw new Error('provider universal-add requires --name, --base-url and --api-key');
            }

            const universalProvider = core.addUniversalProvider({
                name,
                baseUrl,
                apiKey,
                websiteUrl: websiteUrl || undefined,
                notes: notes || undefined,
                apps: readUniversalApps(rest),
                models: readUniversalModels(rest),
            });

            const applied = core.applyUniversalProvider({ id: universalProvider.id });
            console.log(
                `Universal provider created: ${universalProvider.id} (${universalProvider.name}), applied ${applied.length} app providers.`
            );
            return;
        }
        case 'universal-apply': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('provider universal-apply requires --id');
            }
            const applied = core.applyUniversalProvider({ id });
            console.log(`Universal provider applied: ${id} (${applied.length} app providers updated)`);
            return;
        }
        case 'universal-delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('provider universal-delete requires --id');
            }
            const deleted = core.deleteUniversalProvider(id);
            console.log(deleted ? `Deleted universal provider: ${id}` : `Universal provider not found: ${id}`);
            return;
        }
        default:
            throw new Error(`Unknown provider subcommand: ${subcommand}`);
    }
}

async function handleHubList(hubPath) {
    console.log(`Listing skills in ${hubPath}:`);
    if (!await fse.pathExists(hubPath)) {
        console.log('  (Hub directory does not exist yet)');
        return;
    }

    const items = await readSkillNamesUnderRoot(hubPath);
    if (items.length === 0) {
        console.log('  (Hub directory is empty)');
        return;
    }

    for (const item of items) {
        console.log(`  - ${item}`);
    }
}

async function handleInstallList({ config, useGlobal, agents }) {
    const scopeName = useGlobal ? 'global' : 'project';
    const selectedAgents = matchAgentsBySelectors(config.agents, agents);

    if (selectedAgents.length === 0) {
        console.error('No matching agents found.');
        return;
    }

    console.log(`Listing installed skills (${scopeName} scope):`);
    for (const agent of selectedAgents) {
        const targetRoot = resolveAgentScopePath(agent, useGlobal);
        const skills = await readSkillNamesUnderRoot(targetRoot);
        const skillLabel = skills.length > 0 ? skills.join(', ') : '(none)';
        console.log(`  - ${agent.name} (${targetRoot}) -> ${skillLabel}`);
    }
}

async function handleList(commandArgs) {
    const parsed = parseScopeArgs(commandArgs, 'list');
    const config = await loadConfig();
    const hubPath = expandHome(config.hubPath);

    if (parsed.positional.length > 0) {
        throw new Error(`list: unexpected arguments: ${parsed.positional.join(' ')}`);
    }

    if (parsed.useHub) {
        await handleHubList(hubPath);
        return;
    }

    await handleInstallList({
        config,
        useGlobal: parsed.useGlobal,
        agents: parsed.agents,
    });
}

async function removeHubSkills(hubPath, skillNames, removeAll) {
    if (!await fse.pathExists(hubPath)) {
        console.log('Hub directory does not exist, nothing to remove.');
        return;
    }

    const targetNames = removeAll ? await readSkillNamesUnderRoot(hubPath) : skillNames;
    if (targetNames.length === 0) {
        console.log('No hub skills matched for removal.');
        return;
    }

    for (const skillName of targetNames) {
        const targetPath = path.join(hubPath, skillName);
        if (!await fse.pathExists(targetPath)) {
            console.log(`  [SKIP] Hub skill not found: ${skillName}`);
            continue;
        }
        await fse.remove(targetPath);
        console.log(`  [OK] Removed hub skill: ${skillName}`);
    }
}

async function removeInstalledSkills({ config, useGlobal, agents, skillNames, removeAll }) {
    const selectedAgents = matchAgentsBySelectors(config.agents, agents);
    if (selectedAgents.length === 0) {
        throw new Error('No matching agents found.');
    }

    for (const agent of selectedAgents) {
        const targetRoot = resolveAgentScopePath(agent, useGlobal);
        if (!await fse.pathExists(targetRoot)) {
            console.log(`  [SKIP] ${agent.name}: target path missing (${targetRoot})`);
            continue;
        }

        const targetNames = removeAll ? await readSkillNamesUnderRoot(targetRoot) : skillNames;
        if (targetNames.length === 0) {
            console.log(`  [SKIP] ${agent.name}: no matching skills to remove`);
            continue;
        }

        for (const skillName of targetNames) {
            const targetPath = path.join(targetRoot, skillName);
            if (!await fse.pathExists(targetPath)) {
                console.log(`  [SKIP] ${agent.name}: ${skillName} not found`);
                continue;
            }

            await fse.remove(targetPath);
            console.log(`  [OK] ${agent.name}: removed ${skillName}`);
        }
    }
}

async function handleRemove(commandArgs) {
    const parsed = parseScopeArgs(commandArgs, 'remove', new Set(['--all']));
    const removeAll = hasFlag(commandArgs, '--all');
    const skillNames = parsed.positional;

    if (!removeAll && skillNames.length === 0) {
        throw new Error('remove requires at least one skill name or --all.');
    }

    const config = await loadConfig();
    const hubPath = expandHome(config.hubPath);

    if (parsed.useHub) {
        await removeHubSkills(hubPath, skillNames, removeAll);
        return;
    }

    await removeInstalledSkills({
        config,
        useGlobal: parsed.useGlobal,
        agents: parsed.agents,
        skillNames,
        removeAll,
    });
}

async function handleSync(commandArgs) {
    const targetName = readArgValue(commandArgs, '--target', '-t');
    const allTargets = commandArgs.includes('--all');

    if (!targetName && !allTargets) {
        console.error('Error: specify --target <name> or --all');
        process.exit(1);
    }

    const config = await loadConfig();
    const hubPath = expandHome(config.hubPath);

    if (!await fse.pathExists(hubPath)) {
        console.log('Hub directory empty, nothing to sync.');
        return;
    }

    let targetAgents = [];
    if (allTargets) {
        targetAgents = config.agents.filter((agent) => agent.enabled);
    } else {
        const normalized = targetName.toLowerCase();
        targetAgents = config.agents.filter((agent) => agent.name.toLowerCase().includes(normalized));
    }

    if (targetAgents.length === 0) {
        console.error('No matching agents found to sync to.');
        return;
    }

    const skills = await fsPromises.readdir(hubPath);
    console.log(`Found ${skills.length} skills in Hub. Syncing to ${targetAgents.length} agents...`);

    for (const agent of targetAgents) {
        const destRoot = expandHome(agent.globalPath);
        console.log(`\nSyncing to Agent: ${agent.name} (${destRoot})...`);
        await fse.ensureDir(destRoot);

        for (const skill of skills) {
            const skillSource = path.join(hubPath, skill);
            const stat = await fse.stat(skillSource);
            if (!stat.isDirectory()) continue;

            const skillDest = path.join(destRoot, skill);

            try {
                await fse.copy(skillSource, skillDest, { overwrite: true });
                console.log(`  [OK] ${skill} -> ${skillDest}`);
            } catch (error) {
                console.error(`  [ERR] Failed to sync ${skill}:`, error);
            }
        }
    }

    console.log('\nSync complete.');
}

async function collectRemoteInstallableSkills(basePath, currentPath, out, rootSkillName) {
    const skillMdPath = path.join(currentPath, 'SKILL.md');
    if (await fse.pathExists(skillMdPath)) {
        const relative = path.relative(basePath, currentPath).split(path.sep).join('/') || '.';
        out.push({
            name: relative === '.' ? rootSkillName : path.basename(currentPath),
            relativePath: relative,
        });
        return;
    }

    const entries = await fsPromises.readdir(currentPath, { withFileTypes: true });
    for (const entry of entries) {
        if (!entry.isDirectory()) continue;
        if (entry.name === '.git' || entry.name === 'node_modules') continue;
        await collectRemoteInstallableSkills(basePath, path.join(currentPath, entry.name), out, rootSkillName);
    }
}

async function listRemoteInstallableSkills(repoUrl, subdir, branch, rootSkillName) {
    const tempDir = await fsPromises.mkdtemp(path.join(os.tmpdir(), 'skills-hub-list-'));
    const git = simpleGit();

    try {
        const cloneArgs = ['--depth', '1'];
        if (branch) {
            cloneArgs.push('--branch', branch);
        }
        await git.clone(repoUrl, tempDir, cloneArgs);

        const localGit = simpleGit(tempDir);
        const resolvedBranch = await localGit.revparse(['--abbrev-ref', 'HEAD']).catch(() => branch || 'unknown');

        const sourceRoot = subdir ? path.join(tempDir, subdir) : tempDir;
        if (!await fse.pathExists(sourceRoot)) {
            throw new Error(`Directory '${subdir}' not found in remote repository.`);
        }

        const installableSkills = [];
        await collectRemoteInstallableSkills(sourceRoot, sourceRoot, installableSkills, rootSkillName);
        installableSkills.sort((a, b) => a.relativePath.localeCompare(b.relativePath));

        return {
            resolvedBranch,
            installableSkills,
        };
    } finally {
        await fse.remove(tempDir);
    }
}

async function handleImport(commandArgs) {
    const parsed = parseImportArgs(commandArgs);
    const { repoUrl, repoWebUrl, subdir, skillName, branch } = parseSkillImportUrl(parsed.url, parsed.branch);
    const config = await loadConfig();
    const hubPath = expandHome(config.hubPath);
    const hubSkillPath = path.join(hubPath, skillName);
    const installMode = parsed.useGlobal || parsed.copyMode || parsed.agents.length > 0;
    const syncMode = parsed.copyMode ? 'copy' : 'link';

    if (parsed.listOnly) {
        const result = await listRemoteInstallableSkills(repoUrl, subdir, branch, skillName);
        console.log(`Installable skills from ${repoWebUrl} (branch: ${result.resolvedBranch}):`);
        if (result.installableSkills.length === 0) {
            console.log('  (none found)');
            return;
        }
        for (const item of result.installableSkills) {
            const pathLabel = item.relativePath === '.' ? '(root)' : item.relativePath;
            console.log(`  - ${item.name} [${pathLabel}]`);
        }
        return;
    }

    const installTargets = [];
    if (installMode) {
        const selectedAgents = matchAgentsBySelectors(config.agents, parsed.agents);
        if (selectedAgents.length === 0) {
            throw new Error('No matching agents found to install skills.');
        }

        for (const agent of selectedAgents) {
            const targetRoot = resolveAgentScopePath(agent, parsed.useGlobal);
            installTargets.push({
                agentName: agent.name,
                targetRoot,
                skillPath: path.join(targetRoot, skillName),
            });
        }
    }

    const conflictTargets = [];
    if (await fse.pathExists(hubSkillPath)) {
        conflictTargets.push({
            label: `Hub skill ${skillName}`,
            path: hubSkillPath,
        });
    }
    for (const target of installTargets) {
        if (await fse.pathExists(target.skillPath)) {
            conflictTargets.push({
                label: `${target.agentName} skill ${skillName}`,
                path: target.skillPath,
            });
        }
    }

    if (conflictTargets.length > 0 && !parsed.autoYes && !isInteractiveTerminal()) {
        throw new Error(`Target already exists: ${conflictTargets[0].path}. Use -y/--yes to overwrite in non-interactive mode.`);
    }

    if (conflictTargets.length > 0 && !parsed.autoYes && isInteractiveTerminal()) {
        for (const target of conflictTargets) {
            const confirmed = await promptYesNo(`${target.label} already exists at ${target.path}. Overwrite?`);
            if (!confirmed) {
                console.log('Import cancelled.');
                return;
            }
        }
    }

    await fse.ensureDir(hubPath);
    if (await fse.pathExists(hubSkillPath)) {
        await fse.remove(hubSkillPath);
    }

    console.log(`  Repo: ${repoUrl}`);
    console.log(`  Subdir: ${subdir || '(root)'}`);
    console.log(`  Hub target: ${hubSkillPath}`);

    const downloadResult = await downloadRemoteSkill(repoUrl, subdir, hubSkillPath, branch);
    const sourceUrl = buildGitSourceUrl(repoWebUrl, downloadResult.resolvedBranch, subdir);
    await attachSkillImportMetadata(hubSkillPath, {
        sourceRepo: repoWebUrl,
        sourceUrl,
        sourceSubdir: subdir,
        sourceLastUpdated: downloadResult.lastUpdatedAt,
        importedAt: new Date().toISOString(),
    });

    console.log(`Successfully imported ${skillName} to Hub from ${repoWebUrl}.`);
    console.log(`Source last updated: ${downloadResult.lastUpdatedAt}`);

    if (!installMode) {
        return;
    }

    console.log(`Installing '${skillName}' to ${installTargets.length} agent target(s) (${syncMode})...`);
    for (const target of installTargets) {
        await syncSkillToTarget(hubSkillPath, target.skillPath, syncMode);
        console.log(`  [OK] ${target.agentName}: ${target.skillPath}`);
    }
}

const CONFIG_PATH = path.join(os.homedir(), '.skills-hub', 'config.json');

const DEFAULT_AGENTS = [
    { name: 'Antigravity', globalPath: path.join(os.homedir(), '.gemini/antigravity/skills'), projectPath: '.agent/skills', enabled: true, isCustom: false },
    { name: 'Claude Code', globalPath: path.join(os.homedir(), '.claude/skills'), projectPath: '.claude/skills', enabled: true, isCustom: false },
    { name: 'Cursor', globalPath: path.join(os.homedir(), '.cursor/skills'), projectPath: '.cursor/skills', enabled: true, isCustom: false },
    { name: 'OpenCode', globalPath: path.join(os.homedir(), '.config/opencode/skill'), projectPath: '.opencode/skill', enabled: false, isCustom: false },
    { name: 'Codex', globalPath: path.join(os.homedir(), '.codex/skills'), projectPath: '.codex/skills', enabled: false, isCustom: false },
    { name: 'Amp', globalPath: path.join(os.homedir(), '.config/agents/skills'), projectPath: '.agents/skills', enabled: false, isCustom: false },
    { name: 'Kilo Code', globalPath: path.join(os.homedir(), '.kilocode/skills'), projectPath: '.kilocode/skills', enabled: false, isCustom: false },
    { name: 'Roo Code', globalPath: path.join(os.homedir(), '.roo/skills'), projectPath: '.roo/skills', enabled: false, isCustom: false },
    { name: 'Goose', globalPath: path.join(os.homedir(), '.config/goose/skills'), projectPath: '.goose/skills', enabled: false, isCustom: false },
    { name: 'Gemini CLI', globalPath: path.join(os.homedir(), '.gemini/skills'), projectPath: '.gemini/skills', enabled: false, isCustom: false },
    { name: 'GitHub Copilot', globalPath: path.join(os.homedir(), '.copilot/skills'), projectPath: '.github/skills', enabled: false, isCustom: false },
    { name: 'Clawdbot', globalPath: path.join(os.homedir(), '.clawdbot/skills'), projectPath: 'skills', enabled: false, isCustom: false },
    { name: 'Droid', globalPath: path.join(os.homedir(), '.factory/skills'), projectPath: '.factory/skills', enabled: false, isCustom: false },
    { name: 'Windsurf', globalPath: path.join(os.homedir(), '.codeium/windsurf/skills'), projectPath: '.windsurf/skills', enabled: false, isCustom: false },
    { name: 'Trae', globalPath: path.join(os.homedir(), '.trae/skills'), projectPath: '.trae/skills', enabled: false, isCustom: false },
    { name: 'Qoder', globalPath: path.join(os.homedir(), '.qoder/skills'), projectPath: '.qoder/skills', enabled: false, isCustom: false },
];

const DEFAULT_CONFIG = {
    hubPath: path.join(os.homedir(), 'skills-hub'),
    projects: [],
    scanRoots: [path.join(os.homedir(), 'workspace')],
    agents: DEFAULT_AGENTS,
};

async function loadConfig() {
    try {
        const content = await fsPromises.readFile(CONFIG_PATH, 'utf-8');
        if (!content.trim()) return DEFAULT_CONFIG;
        const userConfig = JSON.parse(content);

        const mergedAgents = [...DEFAULT_AGENTS];
        const userAgents = userConfig.agents || [];

        mergedAgents.forEach((agent, index) => {
            const userAgent = userAgents.find((ua) => ua.name === agent.name);
            if (userAgent) {
                mergedAgents[index] = {
                    ...agent,
                    enabled: userAgent.enabled,
                    projectPath: userAgent.projectPath,
                    globalPath: userAgent.globalPath,
                };
            }
        });

        const customAgents = userAgents.filter((ua) => ua.isCustom);

        return {
            ...DEFAULT_CONFIG,
            ...userConfig,
            agents: [...mergedAgents, ...customAgents],
        };
    } catch {
        return DEFAULT_CONFIG;
    }
}

async function resolveDefaultBranch(git) {
    try {
        const result = await git.listRemote(['--symref', 'origin', 'HEAD']);
        const match = result.match(/ref:\s+refs\/heads\/([^\s]+)\s+HEAD/);
        return match ? match[1] : null;
    } catch {
        return null;
    }
}

async function downloadRemoteSkill(repoUrl, subdir, destPath, branch) {
    const tempDir = await fsPromises.mkdtemp(path.join(os.tmpdir(), 'skills-hub-import-'));
    const git = simpleGit(tempDir);

    try {
        await git.init();
        await git.addRemote('origin', repoUrl);
        await git.addConfig('core.sparseCheckout', 'true');

        if (subdir) {
            await fsPromises.writeFile(path.join(tempDir, '.git/info/sparse-checkout'), `${subdir}\n`, 'utf-8');
        } else {
            await fsPromises.writeFile(path.join(tempDir, '.git/info/sparse-checkout'), '*\n', 'utf-8');
        }

        const requestedBranch = branch ? branch.trim() : '';
        const defaultBranch = requestedBranch ? null : await resolveDefaultBranch(git);
        const branchesToTry = requestedBranch
            ? [requestedBranch]
            : defaultBranch
                ? [defaultBranch]
                : ['main', 'master'];

        let pulledBranch = '';
        let lastError;
        for (const candidate of branchesToTry) {
            try {
                await git.pull('origin', candidate, { '--depth': 1 });
                pulledBranch = candidate;
                break;
            } catch (error) {
                lastError = error;
            }
        }

        if (!pulledBranch) {
            throw lastError instanceof Error
                ? lastError
                : new Error('Failed to resolve default branch for remote repository.');
        }

        const logArgs = ['log', '-1', '--format=%cI'];
        if (subdir) {
            logArgs.push('--', subdir);
        }
        let lastUpdatedAt = new Date().toISOString();
        try {
            const lastUpdatedAtRaw = await git.raw(logArgs);
            lastUpdatedAt = lastUpdatedAtRaw.trim() || lastUpdatedAt;
        } catch {
            // Keep fallback timestamp to avoid import failure on metadata lookup issues.
        }

        const sourceContentPath = subdir ? path.join(tempDir, subdir) : tempDir;

        if (!await fse.pathExists(sourceContentPath)) {
            throw new Error(`Directory '${subdir}' not found in remote repository.`);
        }

        await fse.ensureDir(path.dirname(destPath));
        await fse.copy(sourceContentPath, destPath);
        return {
            resolvedBranch: pulledBranch,
            lastUpdatedAt,
        };
    } finally {
        await fse.remove(tempDir);
    }
}

main().catch((error) => {
    console.error(`Command failed: ${error.message || error}`);
    process.exit(1);
});
