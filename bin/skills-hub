#!/usr/bin/env node
'use strict';

const fs = require('fs');
const fsPromises = require('fs/promises');
const fse = require('fs-extra');
const path = require('path');
const http = require('http');
const os = require('os');
const simpleGit = require('simple-git');
const matter = require('gray-matter');
const { spawn } = require('child_process');
const net = require('net');

const args = process.argv.slice(2);
const commands = new Set(['import', 'list', 'sync', 'provider']);
const flagsWithValues = new Set([
    '-p',
    '--port',
    '-H',
    '--host',
    '-b',
    '--branch',
    '--target',
    '-t',
    '--app',
    '--id',
    '--name',
    '--note',
    '--website',
    '--account-name',
    '--vendor-key',
    '--base-url',
    '--api-key',
    '--apps',
    '--claude-model',
    '--codex-model',
    '--gemini-model',
    '--config-json',
    '--config-file',
]);
let providerCorePromise = null;

let command = null;
let commandIndex = -1;

for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.startsWith('-')) {
        // Check if it's a flag=value style
        if (arg.includes('=')) continue;

        // Check if it's a flag that takes a value next
        if (flagsWithValues.has(arg)) {
            i++; // Skip the next argument (the value)
        }
    } else {
        // Found the first non-flag argument, closest thing to a command
        command = arg;
        commandIndex = i;
        break;
    }
}

if (args.includes('--help') || args.includes('-h')) {
    printHelp();
    process.exit(0);
}

if (args.includes('--version') || args.includes('-v') || args.includes('-V')) {
    const pkg = require(path.join(__dirname, '..', 'package.json'));
    console.log(pkg.version);
    process.exit(0);
}

if (command && !commands.has(command)) {
    console.error(`Unknown command: ${command}`);
    printHelp();
    process.exit(1);
}

if (command) {
    const commandArgs = args.slice(commandIndex + 1);
    runCommand(command, commandArgs).catch((error) => {
        console.error(`Command failed: ${error.message || error}`);
        process.exit(1);
    });
} else {
    startServer(args).catch((error) => {
        console.error(`Failed to start server: ${error.message}`);
        process.exit(1);
    });
}

function printHelp() {
    console.log(`Usage:
  skills-hub [options]
  skills-hub <command> [options]

Commands:
  import <url> [--branch <branch>]   Import a skill from a git repository
  list                               List skills in the hub directory
  sync --all | --target <name>       Sync hub skills to agent targets
  provider <subcommand>              Manage provider profiles and switching

Provider subcommands:
  provider list [--app <app>]                                List providers
  provider add --app <app> --name <name> --config-json <json>
  provider add --app <app> --name <name> --config-file <path>
  provider update --id <id> [--name <name>] [--config-json <json>|--config-file <path>]
  provider switch --app <app> --id <providerId>              Switch current provider
  provider delete --id <providerId>                          Delete a provider
  provider restore --app <app>                               Restore latest live backup
  provider capture --app <app> --name <name>                 Capture current live config as provider
  provider universal-list                                     List universal providers
  provider universal-add --name <name> --base-url <url> --api-key <key> [--apps claude,codex,gemini]
  provider universal-apply --id <universalProviderId>        Apply universal provider to enabled apps
  provider universal-delete --id <universalProviderId>       Delete universal provider

Server options:
  -p, --port <port>   Port to run the server (default: 3000)
  -H, --host <host>   Host to bind (default: 127.0.0.1)
  --no-open           Do not open the browser automatically
  -v, --version       Show version number
  -h, --help          Show this help message
`);
}

function readArgValue(argv, flag, shortFlag) {
    const index = argv.indexOf(flag);
    if (index !== -1 && index + 1 < argv.length) {
        return argv[index + 1];
    }

    if (shortFlag) {
        const shortIndex = argv.indexOf(shortFlag);
        if (shortIndex !== -1 && shortIndex + 1 < argv.length) {
            return argv[shortIndex + 1];
        }
    }

    const withEq = argv.find((arg) => arg.startsWith(`${flag}=`));
    if (withEq) {
        return withEq.split('=').slice(1).join('=');
    }

    return null;
}

function expandHome(inputPath) {
    if (!inputPath) return inputPath;
    if (inputPath.startsWith('~')) {
        return path.join(os.homedir(), inputPath.slice(1));
    }
    return inputPath;
}

function normalizeRepoWebUrl(url) {
    return url.trim().replace(/\/$/, '').replace(/\.git$/, '');
}

function parseSkillImportUrl(url, preferredBranch) {
    const input = url.trim();
    if (!input) {
        throw new Error('Missing URL for import.');
    }

    let repoWebUrl = '';
    let branch = preferredBranch ? preferredBranch.trim() : '';
    let subdir = '';

    if (input.includes('/tree/')) {
        const [base, restRaw = ''] = input.split('/tree/', 2);
        repoWebUrl = normalizeRepoWebUrl(base);

        const rest = restRaw.replace(/^\/+/, '');
        if (rest) {
            const parts = rest.split('/').filter(Boolean);
            if (!branch && parts.length > 0) {
                branch = parts[0];
            }
            if (parts.length > 1) {
                subdir = parts.slice(1).join('/');
            }
        }
    } else {
        repoWebUrl = normalizeRepoWebUrl(input);
    }

    const skillName = subdir ? path.basename(subdir) : path.basename(repoWebUrl);
    if (!repoWebUrl || !skillName) {
        throw new Error('Invalid skill import URL.');
    }

    return {
        repoUrl: `${repoWebUrl}.git`,
        repoWebUrl,
        branch: branch || undefined,
        subdir,
        skillName,
    };
}

function buildGitSourceUrl(repoWebUrl, branch, subdir) {
    const normalized = normalizeRepoWebUrl(repoWebUrl);
    if (!branch) {
        return normalized;
    }
    if (subdir) {
        return `${normalized}/tree/${branch}/${subdir}`;
    }
    return `${normalized}/tree/${branch}`;
}

async function attachSkillImportMetadata(skillDirPath, metadata) {
    const skillMdPath = path.join(skillDirPath, 'SKILL.md');
    if (!await fse.pathExists(skillMdPath)) {
        return;
    }

    const rawContent = await fsPromises.readFile(skillMdPath, 'utf-8');
    const parsed = matter(rawContent);
    const nextFrontmatter = {
        ...parsed.data,
        source_repo: metadata.sourceRepo,
        source_url: metadata.sourceUrl,
        source_branch: metadata.sourceBranch,
        source_subdir: metadata.sourceSubdir || '/',
        source_last_updated: metadata.sourceLastUpdated,
        imported_at: metadata.importedAt,
    };

    const nextRawContent = matter.stringify(parsed.content, nextFrontmatter);
    await fsPromises.writeFile(skillMdPath, nextRawContent, 'utf-8');
}

async function runCommand(commandName, commandArgs) {
    switch (commandName) {
        case 'import':
            await handleImport(commandArgs);
            return;
        case 'list':
            await handleList();
            return;
        case 'sync':
            await handleSync(commandArgs);
            return;
        case 'provider':
            await handleProvider(commandArgs);
            return;
        default:
            console.error(`Unknown command: ${commandName}`);
            process.exit(1);
    }
}

function loadProviderCore() {
    if (!providerCorePromise) {
        providerCorePromise = import('../lib/core/provider-core.mjs');
    }
    return providerCorePromise;
}

function parseJsonArg(jsonText) {
    try {
        const parsed = JSON.parse(jsonText);
        if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {
            throw new Error('must be a JSON object');
        }
        return parsed;
    } catch (error) {
        throw new Error(`Invalid JSON config: ${error.message || error}`);
    }
}

async function readProviderConfigFromArgs(commandArgs) {
    const configJson = readArgValue(commandArgs, '--config-json');
    const configFile = readArgValue(commandArgs, '--config-file');

    if (configJson && configFile) {
        throw new Error('Use either --config-json or --config-file, not both.');
    }

    if (configJson) {
        return parseJsonArg(configJson);
    }

    if (configFile) {
        const resolved = path.resolve(configFile);
        const raw = await fsPromises.readFile(resolved, 'utf-8');
        return parseJsonArg(raw);
    }

    return undefined;
}

function readProviderProfileArgs(commandArgs, defaultKind = 'api') {
    const note = readArgValue(commandArgs, '--note');
    const website = readArgValue(commandArgs, '--website');
    const accountName = readArgValue(commandArgs, '--account-name');
    const vendorKey = readArgValue(commandArgs, '--vendor-key');

    return {
        kind: defaultKind,
        note: note || undefined,
        website: website || undefined,
        accountName: accountName || undefined,
        vendorKey: vendorKey || undefined,
    };
}

function readUniversalApps(commandArgs) {
    const raw = readArgValue(commandArgs, '--apps');
    if (!raw) {
        return {
            claude: true,
            codex: true,
            gemini: true,
        };
    }

    const set = new Set(
        raw
            .split(',')
            .map((item) => item.trim().toLowerCase())
            .filter(Boolean)
    );

    return {
        claude: set.has('claude'),
        codex: set.has('codex'),
        gemini: set.has('gemini'),
    };
}

function readUniversalModels(commandArgs) {
    const claudeModel = readArgValue(commandArgs, '--claude-model');
    const codexModel = readArgValue(commandArgs, '--codex-model');
    const geminiModel = readArgValue(commandArgs, '--gemini-model');

    return {
        claude: { model: claudeModel || undefined },
        codex: { model: codexModel || undefined },
        gemini: { model: geminiModel || undefined },
    };
}

function printProviderRow(provider) {
    const currentLabel = provider.isCurrent ? ' (current)' : '';
    console.log(`- ${provider.id} | ${provider.appType} | ${provider.name}${currentLabel}`);
}

function printUniversalProviderRow(provider) {
    const enabledApps = ['claude', 'codex', 'gemini'].filter((app) => provider.apps?.[app]).join(',');
    console.log(`- ${provider.id} | ${provider.name} | ${provider.baseUrl} | apps=${enabledApps || 'none'}`);
}

async function handleProvider(commandArgs) {
    const subcommand = commandArgs[0];
    if (!subcommand) {
        throw new Error('Missing provider subcommand. Try: provider list|add|update|switch|delete|restore|capture|universal-list|universal-add|universal-apply|universal-delete');
    }

    const core = await loadProviderCore();

    switch (subcommand) {
        case 'list': {
            const appType = readArgValue(commandArgs.slice(1), '--app');
            const providers = core.maskProviders(core.listProviders(appType || undefined));
            if (providers.length === 0) {
                console.log('No providers found.');
                return;
            }
            providers.forEach(printProviderRow);
            return;
        }
        case 'add': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            const name = readArgValue(rest, '--name');
            if (!appType || !name) {
                throw new Error('provider add requires --app and --name');
            }
            const config = await readProviderConfigFromArgs(rest);
            if (!config) {
                throw new Error('provider add requires --config-json or --config-file');
            }
            const profile = readProviderProfileArgs(rest, 'api');
            const provider = core.addProvider({
                appType,
                name,
                config: {
                    ...config,
                    _profile: {
                        ...(config._profile || {}),
                        ...profile,
                    },
                },
            });
            console.log(`Provider created: ${provider.id} (${provider.appType} / ${provider.name})`);
            return;
        }
        case 'update': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            const name = readArgValue(rest, '--name');
            if (!id) {
                throw new Error('provider update requires --id');
            }
            const config = await readProviderConfigFromArgs(rest);
            if (name === null && config === undefined) {
                throw new Error('provider update requires at least one of --name / --config-json / --config-file');
            }
            const provider = core.updateProvider({ id, name: name || undefined, config });
            console.log(`Provider updated: ${provider.id} (${provider.name})`);
            return;
        }
        case 'switch': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            const id = readArgValue(rest, '--id');
            if (!appType || !id) {
                throw new Error('provider switch requires --app and --id');
            }
            const result = await core.switchProvider({ appType, providerId: id });
            console.log(
                `Switched ${result.appType}: ${result.switchedFrom || 'none'} -> ${result.switchedTo} (backup #${result.backupId})`
            );
            return;
        }
        case 'delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('provider delete requires --id');
            }
            const deleted = core.deleteProvider(id);
            console.log(deleted ? `Deleted provider: ${id}` : `Provider not found: ${id}`);
            return;
        }
        case 'restore': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            if (!appType) {
                throw new Error('provider restore requires --app');
            }
            const restored = await core.restoreBackup(appType);
            console.log(`Restored ${appType} live config from backup #${restored.id}.`);
            return;
        }
        case 'capture': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            const name = readArgValue(rest, '--name');
            if (!appType || !name) {
                throw new Error('provider capture requires --app and --name');
            }
            const profile = readProviderProfileArgs(rest, 'official');
            const provider = await core.captureProviderFromLive({
                appType,
                name,
                profile,
            });
            console.log(`Provider captured from live config: ${provider.id} (${provider.appType} / ${provider.name})`);
            return;
        }
        case 'universal-list': {
            const universalProviders = core.listUniversalProviders();
            if (universalProviders.length === 0) {
                console.log('No universal providers found.');
                return;
            }
            universalProviders.forEach(printUniversalProviderRow);
            return;
        }
        case 'universal-add': {
            const rest = commandArgs.slice(1);
            const name = readArgValue(rest, '--name');
            const baseUrl = readArgValue(rest, '--base-url');
            const apiKey = readArgValue(rest, '--api-key');
            const websiteUrl = readArgValue(rest, '--website');
            const notes = readArgValue(rest, '--note');

            if (!name || !baseUrl || !apiKey) {
                throw new Error('provider universal-add requires --name, --base-url and --api-key');
            }

            const universalProvider = core.addUniversalProvider({
                name,
                baseUrl,
                apiKey,
                websiteUrl: websiteUrl || undefined,
                notes: notes || undefined,
                apps: readUniversalApps(rest),
                models: readUniversalModels(rest),
            });

            const applied = core.applyUniversalProvider({ id: universalProvider.id });
            console.log(
                `Universal provider created: ${universalProvider.id} (${universalProvider.name}), applied ${applied.length} app providers.`
            );
            return;
        }
        case 'universal-apply': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('provider universal-apply requires --id');
            }
            const applied = core.applyUniversalProvider({ id });
            console.log(`Universal provider applied: ${id} (${applied.length} app providers updated)`);
            return;
        }
        case 'universal-delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('provider universal-delete requires --id');
            }
            const deleted = core.deleteUniversalProvider(id);
            console.log(deleted ? `Deleted universal provider: ${id}` : `Universal provider not found: ${id}`);
            return;
        }
        default:
            throw new Error(`Unknown provider subcommand: ${subcommand}`);
    }
}

async function handleList() {
    const config = await loadConfig();
    const hubPath = expandHome(config.hubPath);

    console.log(`Listing skills in ${hubPath}:`);
    if (!await fse.pathExists(hubPath)) {
        console.log('  (Hub directory does not exist yet)');
        return;
    }

    const items = await fsPromises.readdir(hubPath);
    for (const item of items) {
        const fullPath = path.join(hubPath, item);
        const stat = await fse.stat(fullPath);
        if (stat.isDirectory()) {
            console.log(`  - ${item}`);
        }
    }
}

async function handleSync(commandArgs) {
    const targetName = readArgValue(commandArgs, '--target', '-t');
    const allTargets = commandArgs.includes('--all');

    if (!targetName && !allTargets) {
        console.error('Error: specify --target <name> or --all');
        process.exit(1);
    }

    const config = await loadConfig();
    const hubPath = expandHome(config.hubPath);

    if (!await fse.pathExists(hubPath)) {
        console.log('Hub directory empty, nothing to sync.');
        return;
    }

    let targetAgents = [];
    if (allTargets) {
        targetAgents = config.agents.filter((agent) => agent.enabled);
    } else {
        const normalized = targetName.toLowerCase();
        targetAgents = config.agents.filter((agent) => agent.name.toLowerCase().includes(normalized));
    }

    if (targetAgents.length === 0) {
        console.error('No matching agents found to sync to.');
        return;
    }

    const skills = await fsPromises.readdir(hubPath);
    console.log(`Found ${skills.length} skills in Hub. Syncing to ${targetAgents.length} agents...`);

    for (const agent of targetAgents) {
        const destRoot = expandHome(agent.globalPath);
        console.log(`\nSyncing to Agent: ${agent.name} (${destRoot})...`);
        await fse.ensureDir(destRoot);

        for (const skill of skills) {
            const skillSource = path.join(hubPath, skill);
            const stat = await fse.stat(skillSource);
            if (!stat.isDirectory()) continue;

            const skillDest = path.join(destRoot, skill);

            try {
                await fse.copy(skillSource, skillDest, { overwrite: true });
                console.log(`  [OK] ${skill} -> ${skillDest}`);
            } catch (error) {
                console.error(`  [ERR] Failed to sync ${skill}:`, error);
            }
        }
    }

    console.log('\nSync complete.');
}

async function handleImport(commandArgs) {
    const branchArg = readArgValue(commandArgs, '--branch', '-b');
    const url = commandArgs.find((arg) => !arg.startsWith('-'));

    if (!url) {
        console.error('Error: Missing URL for import.');
        console.log('Usage: skills-hub import <url> [--branch <branch>]');
        process.exit(1);
    }

    const { repoUrl, repoWebUrl, subdir, skillName, branch } = parseSkillImportUrl(url, branchArg);
    const config = await loadConfig();
    const hubPath = expandHome(config.hubPath);
    const destPath = path.join(hubPath, skillName);

    console.log(`  Repo: ${repoUrl}`);
    console.log(`  Subdir: ${subdir || '(root)'}`);
    console.log(`  Target: ${destPath}`);

    if (await fse.pathExists(destPath)) {
        console.error(`Error: Skill '${skillName}' already exists at ${destPath}`);
        process.exit(1);
    }

    const downloadResult = await downloadRemoteSkill(repoUrl, subdir, destPath, branch);
    const sourceUrl = buildGitSourceUrl(repoWebUrl, downloadResult.resolvedBranch, subdir);
    await attachSkillImportMetadata(destPath, {
        sourceRepo: repoWebUrl,
        sourceUrl,
        sourceBranch: downloadResult.resolvedBranch,
        sourceSubdir: subdir,
        sourceLastUpdated: downloadResult.lastUpdatedAt,
        importedAt: new Date().toISOString(),
    });

    console.log(`Successfully imported ${skillName} from ${repoWebUrl}!`);
    console.log(`Source last updated: ${downloadResult.lastUpdatedAt}`);
}

const CONFIG_PATH = path.join(os.homedir(), '.skills-hub', 'config.json');

const DEFAULT_AGENTS = [
    { name: 'Antigravity', globalPath: path.join(os.homedir(), '.gemini/antigravity/skills'), projectPath: '.agent/skills', enabled: true, isCustom: false },
    { name: 'Claude Code', globalPath: path.join(os.homedir(), '.claude/skills'), projectPath: '.claude/skills', enabled: true, isCustom: false },
    { name: 'Cursor', globalPath: path.join(os.homedir(), '.cursor/skills'), projectPath: '.cursor/skills', enabled: true, isCustom: false },
    { name: 'OpenCode', globalPath: path.join(os.homedir(), '.config/opencode/skill'), projectPath: '.opencode/skill', enabled: false, isCustom: false },
    { name: 'Codex', globalPath: path.join(os.homedir(), '.codex/skills'), projectPath: '.codex/skills', enabled: false, isCustom: false },
    { name: 'Amp', globalPath: path.join(os.homedir(), '.config/agents/skills'), projectPath: '.agents/skills', enabled: false, isCustom: false },
    { name: 'Kilo Code', globalPath: path.join(os.homedir(), '.kilocode/skills'), projectPath: '.kilocode/skills', enabled: false, isCustom: false },
    { name: 'Roo Code', globalPath: path.join(os.homedir(), '.roo/skills'), projectPath: '.roo/skills', enabled: false, isCustom: false },
    { name: 'Goose', globalPath: path.join(os.homedir(), '.config/goose/skills'), projectPath: '.goose/skills', enabled: false, isCustom: false },
    { name: 'Gemini CLI', globalPath: path.join(os.homedir(), '.gemini/skills'), projectPath: '.gemini/skills', enabled: false, isCustom: false },
    { name: 'GitHub Copilot', globalPath: path.join(os.homedir(), '.copilot/skills'), projectPath: '.github/skills', enabled: false, isCustom: false },
    { name: 'Clawdbot', globalPath: path.join(os.homedir(), '.clawdbot/skills'), projectPath: 'skills', enabled: false, isCustom: false },
    { name: 'Droid', globalPath: path.join(os.homedir(), '.factory/skills'), projectPath: '.factory/skills', enabled: false, isCustom: false },
    { name: 'Windsurf', globalPath: path.join(os.homedir(), '.codeium/windsurf/skills'), projectPath: '.windsurf/skills', enabled: false, isCustom: false },
    { name: 'Trae', globalPath: path.join(os.homedir(), '.trae/skills'), projectPath: '.trae/skills', enabled: false, isCustom: false },
    { name: 'Qoder', globalPath: path.join(os.homedir(), '.qoder/skills'), projectPath: '.qoder/skills', enabled: false, isCustom: false },
];

const DEFAULT_CONFIG = {
    hubPath: path.join(os.homedir(), 'skills-hub'),
    projects: [],
    scanRoots: [path.join(os.homedir(), 'workspace')],
    agents: DEFAULT_AGENTS,
};

async function loadConfig() {
    try {
        const content = await fsPromises.readFile(CONFIG_PATH, 'utf-8');
        if (!content.trim()) return DEFAULT_CONFIG;
        const userConfig = JSON.parse(content);

        const mergedAgents = [...DEFAULT_AGENTS];
        const userAgents = userConfig.agents || [];

        mergedAgents.forEach((agent, index) => {
            const userAgent = userAgents.find((ua) => ua.name === agent.name);
            if (userAgent) {
                mergedAgents[index] = {
                    ...agent,
                    enabled: userAgent.enabled,
                    projectPath: userAgent.projectPath,
                    globalPath: userAgent.globalPath,
                };
            }
        });

        const customAgents = userAgents.filter((ua) => ua.isCustom);

        return {
            ...DEFAULT_CONFIG,
            ...userConfig,
            agents: [...mergedAgents, ...customAgents],
        };
    } catch {
        return DEFAULT_CONFIG;
    }
}

async function resolveDefaultBranch(git) {
    try {
        const result = await git.listRemote(['--symref', 'origin', 'HEAD']);
        const match = result.match(/ref:\s+refs\/heads\/([^\s]+)\s+HEAD/);
        return match ? match[1] : null;
    } catch {
        return null;
    }
}

async function downloadRemoteSkill(repoUrl, subdir, destPath, branch) {
    const tempDir = await fsPromises.mkdtemp(path.join(os.tmpdir(), 'skills-hub-import-'));
    const git = simpleGit(tempDir);

    try {
        await git.init();
        await git.addRemote('origin', repoUrl);
        await git.addConfig('core.sparseCheckout', 'true');

        if (subdir) {
            await fsPromises.writeFile(path.join(tempDir, '.git/info/sparse-checkout'), `${subdir}\n`, 'utf-8');
        } else {
            await fsPromises.writeFile(path.join(tempDir, '.git/info/sparse-checkout'), '*\n', 'utf-8');
        }

        const requestedBranch = branch ? branch.trim() : '';
        const defaultBranch = requestedBranch ? null : await resolveDefaultBranch(git);
        const branchesToTry = requestedBranch
            ? [requestedBranch]
            : defaultBranch
                ? [defaultBranch]
                : ['main', 'master'];

        let pulledBranch = '';
        let lastError;
        for (const candidate of branchesToTry) {
            try {
                await git.pull('origin', candidate, { '--depth': 1 });
                pulledBranch = candidate;
                break;
            } catch (error) {
                lastError = error;
            }
        }

        if (!pulledBranch) {
            throw lastError instanceof Error
                ? lastError
                : new Error('Failed to resolve default branch for remote repository.');
        }

        const logArgs = ['log', '-1', '--format=%cI'];
        if (subdir) {
            logArgs.push('--', subdir);
        }
        let lastUpdatedAt = new Date().toISOString();
        try {
            const lastUpdatedAtRaw = await git.raw(logArgs);
            lastUpdatedAt = lastUpdatedAtRaw.trim() || lastUpdatedAt;
        } catch {
            // Keep fallback timestamp to avoid import failure on metadata lookup issues.
        }

        const sourceContentPath = subdir ? path.join(tempDir, subdir) : tempDir;

        if (!await fse.pathExists(sourceContentPath)) {
            throw new Error(`Directory '${subdir}' not found in remote repository.`);
        }

        await fse.ensureDir(path.dirname(destPath));
        await fse.copy(sourceContentPath, destPath);
        return {
            resolvedBranch: pulledBranch,
            lastUpdatedAt,
        };
    } finally {
        await fse.remove(tempDir);
    }
}

function checkPortAvailable(port, host) {
    return new Promise((resolve) => {
        const server = net.createServer();
        server.once('error', (err) => {
            if (err.code === 'EADDRINUSE') {
                resolve(false);
            } else {
                resolve(false);
            }
        });
        server.once('listening', () => {
            server.close(() => {
                resolve(true);
            });
        });
        server.listen(port, host);
    });
}

async function findAvailablePort(startPort, host) {
    let port = startPort;
    // Check up to 10 ports
    for (let i = 0; i < 10; i++) {
        if (await checkPortAvailable(port, host)) {
            return port;
        }
        port++;
    }
    // If we can't find one in 10 tries, just return the start port and let it fail naturally
    return startPort;
}

async function startServer(serverArgs) {
    const portValue = readArgValue(serverArgs, '--port', '-p') || process.env.PORT;
    const hostValue = readArgValue(serverArgs, '--host', '-H') || process.env.HOSTNAME || process.env.HOST;
    let port = portValue ? Number(portValue) : 3000;
    const host = hostValue || '127.0.0.1';
    const shouldOpen = !serverArgs.includes('--no-open') && process.env.NO_OPEN !== '1';

    if (!Number.isFinite(port) || port <= 0) {
        console.error(`Invalid port: ${portValue}`);
        process.exit(1);
    }

    // Resolve port availability
    const resolvedPort = await findAvailablePort(port, host);
    if (resolvedPort !== port) {
        console.log(`Port ${port} is in use, using ${resolvedPort} instead.`);
        port = resolvedPort;
    }

    const root = path.resolve(__dirname, '..');
    const standaloneDir = path.join(root, '.next', 'standalone');
    const standaloneServer = path.join(standaloneDir, 'server.js');

    if (!fs.existsSync(standaloneServer)) {
        console.error('Standalone build not found. Run `npm run build` before running skills-hub.');
        process.exit(1);
    }

    const child = spawn(process.execPath, ['server.js'], {
        cwd: standaloneDir,
        env: {
            ...process.env,
            NODE_ENV: process.env.NODE_ENV || 'production',
            PORT: String(port),
            HOST: host,
            HOSTNAME: host,
        },
        stdio: 'inherit',
    });

    const urlHost = host === '0.0.0.0' ? '127.0.0.1' : host;
    const url = `http://${urlHost}:${port}`;

    waitForServer(url, 30000)
        .then(() => {
            console.log(`\nSkills Hub running at ${url}`);
            if (shouldOpen) {
                openBrowser(url);
            }
        })
        .catch((error) => {
            console.error(`Failed to start server: ${error.message}`);
        });

    child.on('exit', (code) => {
        process.exit(code == null ? 0 : code);
    });

    process.on('SIGINT', () => {
        child.kill('SIGINT');
    });

    process.on('SIGTERM', () => {
        child.kill('SIGTERM');
    });
}

function waitForServer(url, timeoutMs) {
    const start = Date.now();
    return new Promise((resolve, reject) => {
        const attempt = () => {
            const req = http.get(url, (res) => {
                res.resume();
                resolve();
            });
            req.on('error', () => {
                if (Date.now() - start > timeoutMs) {
                    reject(new Error(`Timed out waiting for ${url}`));
                    return;
                }
                setTimeout(attempt, 400);
            });
        };
        attempt();
    });
}

function openBrowser(url) {
    const platform = process.platform;
    let cmd = '';
    let cmdArgs = [];

    if (platform === 'darwin') {
        cmd = 'open';
        cmdArgs = [url];
    } else if (platform === 'win32') {
        cmd = 'cmd';
        cmdArgs = ['/c', 'start', '', url];
    } else {
        cmd = 'xdg-open';
        cmdArgs = [url];
    }

    try {
        const opener = spawn(cmd, cmdArgs, { stdio: 'ignore', detached: true });
        opener.unref();
    } catch (error) {
        console.warn(`Failed to open browser: ${error.message}`);
    }
}
