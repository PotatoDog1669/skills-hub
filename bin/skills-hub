#!/usr/bin/env node
'use strict';

const fsPromises = require('fs/promises');
const fse = require('fs-extra');
const path = require('path');
const os = require('os');
const simpleGit = require('simple-git');
const matter = require('gray-matter');

const args = process.argv.slice(2);
const commands = new Set(['import', 'list', 'sync', 'provider', 'kit']);
const flagsWithValues = new Set([
    '-b',
    '--branch',
    '--target',
    '-t',
    '--app',
    '--id',
    '--name',
    '--note',
    '--website',
    '--account-name',
    '--vendor-key',
    '--base-url',
    '--api-key',
    '--apps',
    '--claude-model',
    '--codex-model',
    '--gemini-model',
    '--config-json',
    '--config-file',
    '--policy-id',
    '--loadout-id',
    '--description',
    '--skills',
    '--project',
    '--agent',
    '--mode',
    '--content',
    '--content-file',
]);
let providerCorePromise = null;
let kitServicePromise = null;
let syncServicePromise = null;

let command = null;
let commandIndex = -1;

for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.startsWith('-')) {
        // Check if it's a flag=value style
        if (arg.includes('=')) continue;

        // Check if it's a flag that takes a value next
        if (flagsWithValues.has(arg)) {
            i++; // Skip the next argument (the value)
        }
    } else {
        // Found the first non-flag argument, closest thing to a command
        command = arg;
        commandIndex = i;
        break;
    }
}

if (args.includes('--help') || args.includes('-h')) {
    printHelp();
    process.exit(0);
}

if (args.includes('--version') || args.includes('-v') || args.includes('-V')) {
    const pkg = require(path.join(__dirname, '..', 'package.json'));
    console.log(pkg.version);
    process.exit(0);
}

if (command && !commands.has(command)) {
    console.error(`Unknown command: ${command}`);
    printHelp();
    process.exit(1);
}

if (command) {
    const commandArgs = args.slice(commandIndex + 1);
    runCommand(command, commandArgs).catch((error) => {
        console.error(`Command failed: ${error.message || error}`);
        process.exit(1);
    });
} else {
    printHelp();
    process.exit(1);
}

function printHelp() {
    console.log(`Usage:
  skills-hub <command> [options]

Commands:
  import <url> [--branch <branch>]   Import a skill from a git repository
  list                               List skills in the hub directory
  sync --all | --target <name> [--dry-run]       Sync hub skills to agent targets
  provider <subcommand>              Manage provider profiles and switching
  kit <subcommand>                   Manage AGENTS templates, loadouts, and kits

Provider subcommands:
  provider list [--app <app>]                                List providers
  provider add --app <app> --name <name> --config-json <json>
  provider add --app <app> --name <name> --config-file <path>
  provider update --id <id> [--name <name>] [--config-json <json>|--config-file <path>]
  provider switch --app <app> --id <providerId>              Switch current provider
  provider delete --id <providerId>                          Delete a provider
  provider restore --app <app>                               Restore latest live backup
  provider capture --app <app> --name <name>                 Capture current live config as provider
  provider universal-list                                     List universal providers
  provider universal-add --name <name> --base-url <url> --api-key <key> [--apps claude,codex,gemini]
  provider universal-apply --id <universalProviderId>        Apply universal provider to enabled apps
  provider universal-delete --id <universalProviderId>       Delete universal provider

Kit subcommands:
  kit policy-list
  kit policy-add --name <name> [--description <text>] (--content <text> | --content-file <path>)
  kit policy-update --id <id> [--name <name>] [--description <text>] [--content <text>|--content-file <path>]
  kit policy-delete --id <id>
  kit loadout-list
  kit loadout-add --name <name> --skills <path1,path2,...> [--description <text>] [--mode copy|link]
  kit loadout-update --id <id> [--name <name>] [--description <text>] [--skills <path1,path2,...>] [--mode copy|link]
  kit loadout-delete --id <id>
  kit list
  kit add --name <name> --policy-id <id> --loadout-id <id> [--description <text>]
  kit update --id <id> [--name <name>] [--policy-id <id>] [--loadout-id <id>] [--description <text>]
  kit delete --id <id>
  kit apply --id <id> --project <path> --agent <name> [--mode copy|link] [--overwrite-agents-md] [--dry-run]

  -v, --version       Show version number
  -h, --help          Show this help message
`);
}

function readArgValue(argv, flag, shortFlag) {
    const index = argv.indexOf(flag);
    if (index !== -1 && index + 1 < argv.length) {
        return argv[index + 1];
    }

    if (shortFlag) {
        const shortIndex = argv.indexOf(shortFlag);
        if (shortIndex !== -1 && shortIndex + 1 < argv.length) {
            return argv[shortIndex + 1];
        }
    }

    const withEq = argv.find((arg) => arg.startsWith(`${flag}=`));
    if (withEq) {
        return withEq.split('=').slice(1).join('=');
    }

    return null;
}

function expandHome(inputPath) {
    if (!inputPath) return inputPath;
    if (inputPath.startsWith('~')) {
        return path.join(os.homedir(), inputPath.slice(1));
    }
    return inputPath;
}

function normalizeRepoWebUrl(url) {
    return url.trim().replace(/\/$/, '').replace(/\.git$/, '');
}

function parseSkillImportUrl(url, preferredBranch) {
    const input = url.trim();
    if (!input) {
        throw new Error('Missing URL for import.');
    }

    let repoWebUrl = '';
    let branch = preferredBranch ? preferredBranch.trim() : '';
    let subdir = '';

    if (input.includes('/tree/')) {
        const [base, restRaw = ''] = input.split('/tree/', 2);
        repoWebUrl = normalizeRepoWebUrl(base);

        const rest = restRaw.replace(/^\/+/, '');
        if (rest) {
            const parts = rest.split('/').filter(Boolean);
            if (!branch && parts.length > 0) {
                branch = parts[0];
            }
            if (parts.length > 1) {
                subdir = parts.slice(1).join('/');
            }
        }
    } else {
        repoWebUrl = normalizeRepoWebUrl(input);
    }

    const skillName = subdir ? path.basename(subdir) : path.basename(repoWebUrl);
    if (!repoWebUrl || !skillName) {
        throw new Error('Invalid skill import URL.');
    }

    return {
        repoUrl: `${repoWebUrl}.git`,
        repoWebUrl,
        branch: branch || undefined,
        subdir,
        skillName,
    };
}

function buildGitSourceUrl(repoWebUrl, branch, subdir) {
    const normalized = normalizeRepoWebUrl(repoWebUrl);
    if (!branch) {
        return normalized;
    }
    if (subdir) {
        return `${normalized}/tree/${branch}/${subdir}`;
    }
    return `${normalized}/tree/${branch}`;
}

async function attachSkillImportMetadata(skillDirPath, metadata) {
    const skillMdPath = path.join(skillDirPath, 'SKILL.md');
    if (!await fse.pathExists(skillMdPath)) {
        return;
    }

    const rawContent = await fsPromises.readFile(skillMdPath, 'utf-8');
    const parsed = matter(rawContent);
    const { source_branch: _ignoredSourceBranch, ...restFrontmatter } = parsed.data || {};
    const nextFrontmatter = {
        ...restFrontmatter,
        source_repo: metadata.sourceRepo,
        source_url: metadata.sourceUrl,
        source_subdir: metadata.sourceSubdir || '/',
        source_last_updated: metadata.sourceLastUpdated,
        imported_at: metadata.importedAt,
    };

    const nextRawContent = matter.stringify(parsed.content, nextFrontmatter);
    await fsPromises.writeFile(skillMdPath, nextRawContent, 'utf-8');
}

async function runCommand(commandName, commandArgs) {
    switch (commandName) {
        case 'import':
            await handleImport(commandArgs);
            return;
        case 'list':
            await handleList();
            return;
        case 'sync':
            await handleSync(commandArgs);
            return;
        case 'provider':
            await handleProvider(commandArgs);
            return;
        case 'kit':
            await handleKit(commandArgs);
            return;
        default:
            console.error(`Unknown command: ${commandName}`);
            process.exit(1);
    }
}

function loadProviderCore() {
    if (!providerCorePromise) {
        providerCorePromise = import('../lib/core/provider-core.mjs');
    }
    return providerCorePromise;
}

function loadKitService() {
    if (!kitServicePromise) {
        kitServicePromise = import('../lib/services/kit-service.mjs');
    }
    return kitServicePromise;
}

function loadSyncService() {
    if (!syncServicePromise) {
        syncServicePromise = import('../lib/services/sync-service.mjs');
    }
    return syncServicePromise;
}

function parseJsonArg(jsonText) {
    try {
        const parsed = JSON.parse(jsonText);
        if (!parsed || typeof parsed !== 'object' || Array.isArray(parsed)) {
            throw new Error('must be a JSON object');
        }
        return parsed;
    } catch (error) {
        throw new Error(`Invalid JSON config: ${error.message || error}`);
    }
}

async function readProviderConfigFromArgs(commandArgs) {
    const configJson = readArgValue(commandArgs, '--config-json');
    const configFile = readArgValue(commandArgs, '--config-file');

    if (configJson && configFile) {
        throw new Error('Use either --config-json or --config-file, not both.');
    }

    if (configJson) {
        return parseJsonArg(configJson);
    }

    if (configFile) {
        const resolved = path.resolve(configFile);
        const raw = await fsPromises.readFile(resolved, 'utf-8');
        return parseJsonArg(raw);
    }

    return undefined;
}

function readProviderProfileArgs(commandArgs, defaultKind = 'api') {
    const note = readArgValue(commandArgs, '--note');
    const website = readArgValue(commandArgs, '--website');
    const accountName = readArgValue(commandArgs, '--account-name');
    const vendorKey = readArgValue(commandArgs, '--vendor-key');

    return {
        kind: defaultKind,
        note: note || undefined,
        website: website || undefined,
        accountName: accountName || undefined,
        vendorKey: vendorKey || undefined,
    };
}

function hasFlag(argv, flag) {
    return argv.includes(flag);
}

function printDryRunPreview(preview) {
    console.log(JSON.stringify(preview));
    const summary = preview && preview.summary && typeof preview.summary === 'object'
        ? preview.summary
        : { total: 0, add: 0, update: 0, delete: 0, link: 0 };
    console.log(
        `Dry run summary: total=${summary.total}, add=${summary.add}, ` +
        `update=${summary.update}, delete=${summary.delete}, link=${summary.link}`
    );

    if (Array.isArray(preview?.warnings) && preview.warnings.length > 0) {
        for (const warning of preview.warnings) {
            console.log(`Warning: ${warning}`);
        }
    }
}

function normalizeKitMode(modeRaw) {
    if (!modeRaw) return 'copy';
    const normalized = String(modeRaw).trim().toLowerCase();
    if (normalized === 'copy' || normalized === 'link') {
        return normalized;
    }
    throw new Error(`Invalid --mode value: ${modeRaw}. Use copy or link.`);
}

function parseSkillsArg(skillsRaw) {
    if (!skillsRaw || !skillsRaw.trim()) {
        throw new Error('Missing --skills value.');
    }

    const skillPaths = skillsRaw
        .split(',')
        .map((entry) => entry.trim())
        .filter(Boolean);

    if (skillPaths.length === 0) {
        throw new Error('At least one skill path is required in --skills.');
    }

    return Array.from(new Set(skillPaths));
}

async function readContentFromArgs(commandArgs) {
    const content = readArgValue(commandArgs, '--content');
    const contentFile = readArgValue(commandArgs, '--content-file');

    if (content && contentFile) {
        throw new Error('Use either --content or --content-file, not both.');
    }

    if (contentFile) {
        const resolved = path.resolve(contentFile);
        return fsPromises.readFile(resolved, 'utf-8');
    }

    if (content) {
        return content;
    }

    return undefined;
}

function readUniversalApps(commandArgs) {
    const raw = readArgValue(commandArgs, '--apps');
    if (!raw) {
        return {
            claude: true,
            codex: true,
            gemini: true,
        };
    }

    const set = new Set(
        raw
            .split(',')
            .map((item) => item.trim().toLowerCase())
            .filter(Boolean)
    );

    return {
        claude: set.has('claude'),
        codex: set.has('codex'),
        gemini: set.has('gemini'),
    };
}

function readUniversalModels(commandArgs) {
    const claudeModel = readArgValue(commandArgs, '--claude-model');
    const codexModel = readArgValue(commandArgs, '--codex-model');
    const geminiModel = readArgValue(commandArgs, '--gemini-model');

    return {
        claude: { model: claudeModel || undefined },
        codex: { model: codexModel || undefined },
        gemini: { model: geminiModel || undefined },
    };
}

function printProviderRow(provider) {
    const currentLabel = provider.isCurrent ? ' (current)' : '';
    console.log(`- ${provider.id} | ${provider.appType} | ${provider.name}${currentLabel}`);
}

function printUniversalProviderRow(provider) {
    const enabledApps = ['claude', 'codex', 'gemini'].filter((app) => provider.apps?.[app]).join(',');
    console.log(`- ${provider.id} | ${provider.name} | ${provider.baseUrl} | apps=${enabledApps || 'none'}`);
}

function printKitPolicyRow(policy) {
    console.log(`- ${policy.id} | ${policy.name}${policy.description ? ` | ${policy.description}` : ''}`);
}

function printKitLoadoutRow(loadout) {
    console.log(`- ${loadout.id} | ${loadout.name} | skills=${loadout.items.length}`);
}

function printKitRow(kit) {
    console.log(`- ${kit.id} | ${kit.name} | policy=${kit.policyId} | loadout=${kit.loadoutId}`);
}

async function handleKit(commandArgs) {
    const subcommand = commandArgs[0];
    if (!subcommand) {
        throw new Error('Missing kit subcommand. Try: kit policy-list|policy-add|loadout-list|add|apply');
    }

    const service = await loadKitService();

    switch (subcommand) {
        case 'policy-list': {
            const policies = service.listKitPolicies();
            if (policies.length === 0) {
                console.log('No AGENTS.md templates found.');
                return;
            }
            policies.forEach(printKitPolicyRow);
            return;
        }
        case 'policy-add': {
            const rest = commandArgs.slice(1);
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const content = await readContentFromArgs(rest);

            if (!name || !content) {
                throw new Error('kit policy-add requires --name and one of --content / --content-file');
            }

            const policy = service.addKitPolicy({
                name,
                description: description || undefined,
                content,
            });
            console.log(`Policy created: ${policy.id} (${policy.name})`);
            return;
        }
        case 'policy-update': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const content = await readContentFromArgs(rest);

            if (!id) {
                throw new Error('kit policy-update requires --id');
            }

            const policy = service.updateKitPolicy({
                id,
                name: name || undefined,
                description: description || undefined,
                content: content === undefined ? undefined : content,
            });
            console.log(`Policy updated: ${policy.id} (${policy.name})`);
            return;
        }
        case 'policy-delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('kit policy-delete requires --id');
            }
            const deleted = service.deleteKitPolicy(id);
            console.log(deleted ? `Deleted policy: ${id}` : `Policy not found: ${id}`);
            return;
        }
        case 'loadout-list': {
            const loadouts = service.listKitLoadouts();
            if (loadouts.length === 0) {
                console.log('No skills packages found.');
                return;
            }
            loadouts.forEach(printKitLoadoutRow);
            return;
        }
        case 'loadout-add': {
            const rest = commandArgs.slice(1);
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const skillsRaw = readArgValue(rest, '--skills');
            const mode = normalizeKitMode(readArgValue(rest, '--mode'));

            if (!name || !skillsRaw) {
                throw new Error('kit loadout-add requires --name and --skills');
            }

            const skillPaths = parseSkillsArg(skillsRaw);
            const loadout = service.addKitLoadout({
                name,
                description: description || undefined,
                items: skillPaths.map((skillPath, index) => ({
                    skillPath,
                    mode,
                    sortOrder: index,
                })),
            });
            console.log(`Loadout created: ${loadout.id} (${loadout.name})`);
            return;
        }
        case 'loadout-update': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const skillsRaw = readArgValue(rest, '--skills');
            const mode = normalizeKitMode(readArgValue(rest, '--mode'));

            if (!id) {
                throw new Error('kit loadout-update requires --id');
            }

            const items = skillsRaw
                ? parseSkillsArg(skillsRaw).map((skillPath, index) => ({
                    skillPath,
                    mode,
                    sortOrder: index,
                }))
                : undefined;

            const loadout = service.updateKitLoadout({
                id,
                name: name || undefined,
                description: description || undefined,
                items,
            });
            console.log(`Loadout updated: ${loadout.id} (${loadout.name})`);
            return;
        }
        case 'loadout-delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('kit loadout-delete requires --id');
            }
            const deleted = service.deleteKitLoadout(id);
            console.log(deleted ? `Deleted loadout: ${id}` : `Loadout not found: ${id}`);
            return;
        }
        case 'list': {
            const kits = service.listKits();
            if (kits.length === 0) {
                console.log('No kits found.');
                return;
            }
            kits.forEach(printKitRow);
            return;
        }
        case 'add': {
            const rest = commandArgs.slice(1);
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const policyId = readArgValue(rest, '--policy-id');
            const loadoutId = readArgValue(rest, '--loadout-id');

            if (!name || !policyId || !loadoutId) {
                throw new Error('kit add requires --name --policy-id --loadout-id');
            }

            const kit = service.addKit({
                name,
                description: description || undefined,
                policyId,
                loadoutId,
            });
            console.log(`Kit created: ${kit.id} (${kit.name})`);
            return;
        }
        case 'update': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            const name = readArgValue(rest, '--name');
            const description = readArgValue(rest, '--description');
            const policyId = readArgValue(rest, '--policy-id');
            const loadoutId = readArgValue(rest, '--loadout-id');

            if (!id) {
                throw new Error('kit update requires --id');
            }

            const kit = service.updateKit({
                id,
                name: name || undefined,
                description: description || undefined,
                policyId: policyId || undefined,
                loadoutId: loadoutId || undefined,
            });
            console.log(`Kit updated: ${kit.id} (${kit.name})`);
            return;
        }
        case 'delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('kit delete requires --id');
            }
            const deleted = service.deleteKit(id);
            console.log(deleted ? `Deleted kit: ${id}` : `Kit not found: ${id}`);
            return;
        }
        case 'apply': {
            const rest = commandArgs.slice(1);
            const kitId = readArgValue(rest, '--id');
            const projectPath = readArgValue(rest, '--project');
            const agentName = readArgValue(rest, '--agent');
            const mode = normalizeKitMode(readArgValue(rest, '--mode'));
            const overwriteAgentsMd = hasFlag(rest, '--overwrite-agents-md');
            const dryRun = hasFlag(rest, '--dry-run');

            if (!kitId || !projectPath || !agentName) {
                throw new Error('kit apply requires --id --project --agent');
            }

            if (dryRun) {
                const preview = await service.previewKitApply({
                    kitId,
                    projectPath,
                    agentName,
                    mode,
                    overwriteAgentsMd,
                });
                printDryRunPreview(preview);
                return;
            }

            const result = await service.applyKit({
                kitId,
                projectPath,
                agentName,
                mode,
                overwriteAgentsMd,
            });

            const successCount = result.loadoutResults.filter((item) => item.status === 'success').length;
            console.log(
                `Kit applied: ${result.kitId} -> ${result.projectPath} (${result.agentName}), ` +
                `skills=${successCount}, policy=${result.policyPath}`
            );
            return;
        }
        default:
            throw new Error(`Unknown kit subcommand: ${subcommand}`);
    }
}

async function handleProvider(commandArgs) {
    const subcommand = commandArgs[0];
    if (!subcommand) {
        throw new Error('Missing provider subcommand. Try: provider list|add|update|switch|delete|restore|capture|universal-list|universal-add|universal-apply|universal-delete');
    }

    const core = await loadProviderCore();

    switch (subcommand) {
        case 'list': {
            const appType = readArgValue(commandArgs.slice(1), '--app');
            const providers = core.maskProviders(core.listProviders(appType || undefined));
            if (providers.length === 0) {
                console.log('No providers found.');
                return;
            }
            providers.forEach(printProviderRow);
            return;
        }
        case 'add': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            const name = readArgValue(rest, '--name');
            if (!appType || !name) {
                throw new Error('provider add requires --app and --name');
            }
            const config = await readProviderConfigFromArgs(rest);
            if (!config) {
                throw new Error('provider add requires --config-json or --config-file');
            }
            const profile = readProviderProfileArgs(rest, 'api');
            const provider = core.addProvider({
                appType,
                name,
                config: {
                    ...config,
                    _profile: {
                        ...(config._profile || {}),
                        ...profile,
                    },
                },
            });
            console.log(`Provider created: ${provider.id} (${provider.appType} / ${provider.name})`);
            return;
        }
        case 'update': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            const name = readArgValue(rest, '--name');
            if (!id) {
                throw new Error('provider update requires --id');
            }
            const config = await readProviderConfigFromArgs(rest);
            if (name === null && config === undefined) {
                throw new Error('provider update requires at least one of --name / --config-json / --config-file');
            }
            const provider = core.updateProvider({ id, name: name || undefined, config });
            console.log(`Provider updated: ${provider.id} (${provider.name})`);
            return;
        }
        case 'switch': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            const id = readArgValue(rest, '--id');
            if (!appType || !id) {
                throw new Error('provider switch requires --app and --id');
            }
            const result = await core.switchProvider({ appType, providerId: id });
            console.log(
                `Switched ${result.appType}: ${result.switchedFrom || 'none'} -> ${result.switchedTo} (backup #${result.backupId})`
            );
            return;
        }
        case 'delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('provider delete requires --id');
            }
            const deleted = core.deleteProvider(id);
            console.log(deleted ? `Deleted provider: ${id}` : `Provider not found: ${id}`);
            return;
        }
        case 'restore': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            if (!appType) {
                throw new Error('provider restore requires --app');
            }
            const restored = await core.restoreBackup(appType);
            console.log(`Restored ${appType} live config from backup #${restored.id}.`);
            return;
        }
        case 'capture': {
            const rest = commandArgs.slice(1);
            const appType = readArgValue(rest, '--app');
            const name = readArgValue(rest, '--name');
            if (!appType || !name) {
                throw new Error('provider capture requires --app and --name');
            }
            const profile = readProviderProfileArgs(rest, 'official');
            const provider = await core.captureProviderFromLive({
                appType,
                name,
                profile,
            });
            console.log(`Provider captured from live config: ${provider.id} (${provider.appType} / ${provider.name})`);
            return;
        }
        case 'universal-list': {
            const universalProviders = core.listUniversalProviders();
            if (universalProviders.length === 0) {
                console.log('No universal providers found.');
                return;
            }
            universalProviders.forEach(printUniversalProviderRow);
            return;
        }
        case 'universal-add': {
            const rest = commandArgs.slice(1);
            const name = readArgValue(rest, '--name');
            const baseUrl = readArgValue(rest, '--base-url');
            const apiKey = readArgValue(rest, '--api-key');
            const websiteUrl = readArgValue(rest, '--website');
            const notes = readArgValue(rest, '--note');

            if (!name || !baseUrl || !apiKey) {
                throw new Error('provider universal-add requires --name, --base-url and --api-key');
            }

            const universalProvider = core.addUniversalProvider({
                name,
                baseUrl,
                apiKey,
                websiteUrl: websiteUrl || undefined,
                notes: notes || undefined,
                apps: readUniversalApps(rest),
                models: readUniversalModels(rest),
            });

            const applied = core.applyUniversalProvider({ id: universalProvider.id });
            console.log(
                `Universal provider created: ${universalProvider.id} (${universalProvider.name}), applied ${applied.length} app providers.`
            );
            return;
        }
        case 'universal-apply': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('provider universal-apply requires --id');
            }
            const applied = core.applyUniversalProvider({ id });
            console.log(`Universal provider applied: ${id} (${applied.length} app providers updated)`);
            return;
        }
        case 'universal-delete': {
            const rest = commandArgs.slice(1);
            const id = readArgValue(rest, '--id');
            if (!id) {
                throw new Error('provider universal-delete requires --id');
            }
            const deleted = core.deleteUniversalProvider(id);
            console.log(deleted ? `Deleted universal provider: ${id}` : `Universal provider not found: ${id}`);
            return;
        }
        default:
            throw new Error(`Unknown provider subcommand: ${subcommand}`);
    }
}

async function handleList() {
    const config = await loadConfig();
    const hubPath = expandHome(config.hubPath);

    console.log(`Listing skills in ${hubPath}:`);
    if (!await fse.pathExists(hubPath)) {
        console.log('  (Hub directory does not exist yet)');
        return;
    }

    const items = await fsPromises.readdir(hubPath);
    for (const item of items) {
        const fullPath = path.join(hubPath, item);
        const stat = await fse.stat(fullPath);
        if (stat.isDirectory()) {
            console.log(`  - ${item}`);
        }
    }
}

async function handleSync(commandArgs) {
    const targetName = readArgValue(commandArgs, '--target', '-t');
    const allTargets = commandArgs.includes('--all');
    const dryRun = hasFlag(commandArgs, '--dry-run');

    if (!targetName && !allTargets) {
        console.error('Error: specify --target <name> or --all');
        process.exit(1);
    }

    const config = await loadConfig();
    const hubPath = expandHome(config.hubPath);

    if (!await fse.pathExists(hubPath)) {
        console.log('Hub directory empty, nothing to sync.');
        return;
    }

    let targetAgents = [];
    if (allTargets) {
        targetAgents = config.agents.filter((agent) => agent.enabled);
    } else {
        const normalized = targetName.toLowerCase();
        targetAgents = config.agents.filter((agent) => agent.name.toLowerCase().includes(normalized));
    }

    if (targetAgents.length === 0) {
        console.error('No matching agents found to sync to.');
        return;
    }

    const syncService = await loadSyncService();
    const skills = await fsPromises.readdir(hubPath);
    const preview = {
        action: 'sync',
        dryRun: true,
        mode: 'copy',
        targetCount: targetAgents.length,
        skillCount: skills.length,
        changes: [],
        summary: { total: 0, add: 0, update: 0, delete: 0, link: 0 },
    };

    if (!dryRun) {
        console.log(`Found ${skills.length} skills in Hub. Syncing to ${targetAgents.length} agents...`);
    }

    for (const agent of targetAgents) {
        const destRoot = expandHome(agent.globalPath);
        if (!dryRun) {
            console.log(`\nSyncing to Agent: ${agent.name} (${destRoot})...`);
        }
        if (!dryRun) {
            await fse.ensureDir(destRoot);
        }

        for (const skill of skills) {
            const skillSource = path.join(hubPath, skill);
            const stat = await fse.stat(skillSource);
            if (!stat.isDirectory()) continue;

            try {
                if (dryRun) {
                    const planned = await syncService.previewSkillSync({
                        sourcePath: skillSource,
                        destParentPath: destRoot,
                        mode: 'copy',
                    });
                    preview.changes.push(...planned.changes);
                } else {
                    const synced = await syncService.syncSkill({
                        sourcePath: skillSource,
                        destParentPath: destRoot,
                        mode: 'copy',
                    });
                    console.log(`  [OK] ${skill} -> ${synced.destination}`);
                }
            } catch (error) {
                console.error(`  [ERR] Failed to sync ${skill}:`, error);
            }
        }
    }

    if (dryRun) {
        preview.summary = syncService.summarizeSyncChanges(preview.changes);
        printDryRunPreview(preview);
        return;
    }

    console.log('\nSync complete.');
}

async function handleImport(commandArgs) {
    const branchArg = readArgValue(commandArgs, '--branch', '-b');
    const url = commandArgs.find((arg) => !arg.startsWith('-'));

    if (!url) {
        console.error('Error: Missing URL for import.');
        console.log('Usage: skills-hub import <url> [--branch <branch>]');
        process.exit(1);
    }

    const { repoUrl, repoWebUrl, subdir, skillName, branch } = parseSkillImportUrl(url, branchArg);
    const config = await loadConfig();
    const hubPath = expandHome(config.hubPath);
    const destPath = path.join(hubPath, skillName);

    console.log(`  Repo: ${repoUrl}`);
    console.log(`  Subdir: ${subdir || '(root)'}`);
    console.log(`  Target: ${destPath}`);

    if (await fse.pathExists(destPath)) {
        console.error(`Error: Skill '${skillName}' already exists at ${destPath}`);
        process.exit(1);
    }

    const downloadResult = await downloadRemoteSkill(repoUrl, subdir, destPath, branch);
    const sourceUrl = buildGitSourceUrl(repoWebUrl, downloadResult.resolvedBranch, subdir);
    await attachSkillImportMetadata(destPath, {
        sourceRepo: repoWebUrl,
        sourceUrl,
        sourceSubdir: subdir,
        sourceLastUpdated: downloadResult.lastUpdatedAt,
        importedAt: new Date().toISOString(),
    });

    console.log(`Successfully imported ${skillName} from ${repoWebUrl}!`);
    console.log(`Source last updated: ${downloadResult.lastUpdatedAt}`);
}

function getConfigPath() {
    return path.join(os.homedir(), '.skills-hub', 'config.json');
}

function buildDefaultAgents() {
    return [
        { name: 'Antigravity', globalPath: path.join(os.homedir(), '.gemini/antigravity/skills'), projectPath: '.agent/skills', enabled: true, isCustom: false },
        { name: 'Claude Code', globalPath: path.join(os.homedir(), '.claude/skills'), projectPath: '.claude/skills', enabled: true, isCustom: false },
        { name: 'Cursor', globalPath: path.join(os.homedir(), '.cursor/skills'), projectPath: '.cursor/skills', enabled: true, isCustom: false },
        { name: 'OpenCode', globalPath: path.join(os.homedir(), '.config/opencode/skill'), projectPath: '.opencode/skill', enabled: false, isCustom: false },
        { name: 'Codex', globalPath: path.join(os.homedir(), '.codex/skills'), projectPath: '.codex/skills', enabled: false, isCustom: false },
        { name: 'Amp', globalPath: path.join(os.homedir(), '.config/agents/skills'), projectPath: '.agents/skills', enabled: false, isCustom: false },
        { name: 'Kilo Code', globalPath: path.join(os.homedir(), '.kilocode/skills'), projectPath: '.kilocode/skills', enabled: false, isCustom: false },
        { name: 'Roo Code', globalPath: path.join(os.homedir(), '.roo/skills'), projectPath: '.roo/skills', enabled: false, isCustom: false },
        { name: 'Goose', globalPath: path.join(os.homedir(), '.config/goose/skills'), projectPath: '.goose/skills', enabled: false, isCustom: false },
        { name: 'Gemini CLI', globalPath: path.join(os.homedir(), '.gemini/skills'), projectPath: '.gemini/skills', enabled: false, isCustom: false },
        { name: 'GitHub Copilot', globalPath: path.join(os.homedir(), '.copilot/skills'), projectPath: '.github/skills', enabled: false, isCustom: false },
        { name: 'Clawdbot', globalPath: path.join(os.homedir(), '.clawdbot/skills'), projectPath: 'skills', enabled: false, isCustom: false },
        { name: 'Droid', globalPath: path.join(os.homedir(), '.factory/skills'), projectPath: '.factory/skills', enabled: false, isCustom: false },
        { name: 'Windsurf', globalPath: path.join(os.homedir(), '.codeium/windsurf/skills'), projectPath: '.windsurf/skills', enabled: false, isCustom: false },
        { name: 'Trae', globalPath: path.join(os.homedir(), '.trae/skills'), projectPath: '.trae/skills', enabled: false, isCustom: false },
        { name: 'Qoder', globalPath: path.join(os.homedir(), '.qoder/skills'), projectPath: '.qoder/skills', enabled: false, isCustom: false },
    ];
}

function buildDefaultConfig() {
    return {
        hubPath: path.join(os.homedir(), 'skills-hub'),
        projects: [],
        scanRoots: [path.join(os.homedir(), 'workspace')],
        agents: buildDefaultAgents(),
    };
}

async function loadConfig() {
    try {
        const defaultConfig = buildDefaultConfig();
        const content = await fsPromises.readFile(getConfigPath(), 'utf-8');
        if (!content.trim()) return defaultConfig;
        const userConfig = JSON.parse(content);

        const mergedAgents = buildDefaultAgents();
        const userAgents = userConfig.agents || [];

        mergedAgents.forEach((agent, index) => {
            const userAgent = userAgents.find((ua) => ua.name === agent.name);
            if (userAgent) {
                mergedAgents[index] = {
                    ...agent,
                    enabled: userAgent.enabled,
                    projectPath: userAgent.projectPath,
                    globalPath: userAgent.globalPath,
                };
            }
        });

        const customAgents = userAgents.filter((ua) => ua.isCustom);

        return {
            ...defaultConfig,
            ...userConfig,
            agents: [...mergedAgents, ...customAgents],
        };
    } catch {
        return buildDefaultConfig();
    }
}

async function resolveDefaultBranch(git) {
    try {
        const result = await git.listRemote(['--symref', 'origin', 'HEAD']);
        const match = result.match(/ref:\s+refs\/heads\/([^\s]+)\s+HEAD/);
        return match ? match[1] : null;
    } catch {
        return null;
    }
}

async function downloadRemoteSkill(repoUrl, subdir, destPath, branch) {
    const tempDir = await fsPromises.mkdtemp(path.join(os.tmpdir(), 'skills-hub-import-'));
    const git = simpleGit(tempDir);

    try {
        await git.init();
        await git.addRemote('origin', repoUrl);
        await git.addConfig('core.sparseCheckout', 'true');

        if (subdir) {
            await fsPromises.writeFile(path.join(tempDir, '.git/info/sparse-checkout'), `${subdir}\n`, 'utf-8');
        } else {
            await fsPromises.writeFile(path.join(tempDir, '.git/info/sparse-checkout'), '*\n', 'utf-8');
        }

        const requestedBranch = branch ? branch.trim() : '';
        const defaultBranch = requestedBranch ? null : await resolveDefaultBranch(git);
        const branchesToTry = requestedBranch
            ? [requestedBranch]
            : defaultBranch
                ? [defaultBranch]
                : ['main', 'master'];

        let pulledBranch = '';
        let lastError;
        for (const candidate of branchesToTry) {
            try {
                await git.pull('origin', candidate, { '--depth': 1 });
                pulledBranch = candidate;
                break;
            } catch (error) {
                lastError = error;
            }
        }

        if (!pulledBranch) {
            throw lastError instanceof Error
                ? lastError
                : new Error('Failed to resolve default branch for remote repository.');
        }

        const logArgs = ['log', '-1', '--format=%cI'];
        if (subdir) {
            logArgs.push('--', subdir);
        }
        let lastUpdatedAt = new Date().toISOString();
        try {
            const lastUpdatedAtRaw = await git.raw(logArgs);
            lastUpdatedAt = lastUpdatedAtRaw.trim() || lastUpdatedAt;
        } catch {
            // Keep fallback timestamp to avoid import failure on metadata lookup issues.
        }

        const sourceContentPath = subdir ? path.join(tempDir, subdir) : tempDir;

        if (!await fse.pathExists(sourceContentPath)) {
            throw new Error(`Directory '${subdir}' not found in remote repository.`);
        }

        await fse.ensureDir(path.dirname(destPath));
        await fse.copy(sourceContentPath, destPath);
        return {
            resolvedBranch: pulledBranch,
            lastUpdatedAt,
        };
    } finally {
        await fse.remove(tempDir);
    }
}
